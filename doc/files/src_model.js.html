<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\model.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Model.html">Model</a></li>
            
                <li><a href="..&#x2F;classes/Property.html">Property</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Model.html">Model</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\model.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Model js - A simple javascript library for creating the Model part of a MVC application.
 * https:&#x2F;&#x2F;github.com&#x2F;dgeorges&#x2F;modeljs.git
 *
 * Copyright 2012, Daniel Georges
 * modeljs is distributed freely under a MIT licence
 *
 * @project modeljs
 * @author Daniel Georges
 * @version 1.0.0
 * @module Model
 *&#x2F;
(function (globalNS, undefined) { &#x2F;&#x2F;globalNS === window in the browser or GLOBAL in nodejs
    &quot;use strict&quot;;

    &#x2F;&#x2F; copied from underscorejs
    function isFunction(fn) {
        return !!fn &amp;&amp; Object.prototype.toString.call(fn) === &#x27;[object Function]&#x27;;
    }

    function isObject(obj) {
        return obj === new Object(obj) &amp;&amp; !isFunction(obj) &amp;&amp; !Array.isArray(obj) &amp;&amp; !(obj instanceof Date);
    }

    function isEmptyObject(obj) {
        if (Object.getOwnPropertyNames) { &#x2F;&#x2F; only exits on ECMAScript 5 compatible browsers
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isValidDate(d) {
        if (Object.prototype.toString.call(d) !== &quot;[object Date]&quot;) {
            return false;
        }
        return !isNaN(d.getTime());
    }

    function log(level, message) {
        &#x2F;&#x2F;Only log when enabled and console log method is available
        if (Model.enableLogging &amp;&amp; globalNS.console &amp;&amp; globalNS.console[level]) {
            globalNS.console[level](message);
        }
    }

    var getXHRObject = (function () {
        if (globalNS.XMLHttpRequest) { &#x2F;&#x2F; Mozilla, Safari, ...
            return function () {
                return new XMLHttpRequest();
            };
        } else if (globalNS.ActiveXObject) { &#x2F;&#x2F; IE
            try {
                new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
                return function () {
                    return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
                };
            } catch (e1) {
                try {
                    new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
                    return function () {
                        return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
                    };
                } catch (e2) {
                    &#x2F;&#x2F;do nothing
                }
            }
        }

        log(&#x27;error&#x27;, &quot;Could not create an XMLHTTPRequestObject Remote Model requests will fail&quot;);
        return undefined;
    }());

    function makeJSONPRequest(url, id) {
        var scriptTag = document.createElement(&quot;SCRIPT&quot;);
        scriptTag.id = id;
        scriptTag.type = &#x27;text&#x2F;javascript&#x27;;
        scriptTag.src = url;
        document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptTag);
    }

    var callbackId = 0;
    function generateJSONPCallback(property) {
        var fnName = &quot;modeljsJSONPCallback&quot; + callbackId++;
        window[fnName] = function (property, json) { &#x2F;&#x2F;create global callback
            property.setValue(json);
            var scriptElement = document.getElementById(fnName);
            document.getElementsByTagName(&#x27;head&#x27;)[0].removeChild(scriptElement); &#x2F;&#x2F;remove callback script
            try {
                delete window[fnName]; &#x2F;&#x2F; remove global callback method
            } catch (e) {
                &#x2F;&#x2F; this seems to throw and exception in IE8 so we will release it get garbage collected.
                window[fnName] = undefined;
            }
        }.bind(null, property);
        return fnName;
    }

    function makeRemoteRequest(property) {
        var url = property.getMetadata().url;
        if (property.getMetadata().isJSONPurl) {
            var uniqueCallbackId = generateJSONPCallback(property);
            url = url.replace(&quot;$jsonpCallback&quot;, uniqueCallbackId);
            makeJSONPRequest(url, uniqueCallbackId);
        } else {
            var httpRequest = getXHRObject();
            httpRequest.onreadystatechange = retrieveRemoteRequest.bind(null, httpRequest, property);
            &#x2F;&#x2F;httpRequest.orgin = &quot;localhost:8080&quot;;
            &#x2F;&#x2F;httpRequest.setRequestHeader
            httpRequest.open(&#x27;GET&#x27;, url);
            httpRequest.send();
        }
    }

    function retrieveRemoteRequest(xhr, property, xhrProgressEvent) {
        if (xhr.readyState === 4) {

            if (xhr.status !== 200) {
                log(&#x27;warn&#x27;, &quot;Remote request for &quot; + property.getName() + &quot; failded due to return status of &quot; + xhr.status);
                if (property.getMetadata().refreshRate === -1) {
                    log(&#x27;warn&#x27;, &quot;Retrying remote request for &quot; + property.getName() + &quot; in 2 seconds&quot;);
                    setTimeout(makeRemoteRequest.bind(null, property), 2000);&#x2F;&#x2F; try again in 2 sec
                }
                return;
            }

            if (xhr.responseType !== &quot;json&quot; &amp;&amp; xhr.responseType !== &quot;&quot;) {
                log(&#x27;error&#x27;, &quot;Remote model (&quot; + property.getName() + &quot;) must return JSON. Not retrying.&quot;);
                return;
            }

            &#x2F;&#x2F;look into ArrayBuffer
            var jsonResponse = {};
            try {
                jsonResponse = JSON.parse(xhr.response);
            } catch (e) {
                log(&#x27;error&#x27;, &quot;Unable to parse remote Model request for &quot; + property.getName());
                return; &#x2F;&#x2F;should retry? makeRemoteRequest(property);
            }

            &#x2F;&#x2F;use response header Last-Modified time stamp to determine if we should call setValue
            var responseLastModifiedDate = xhr.getResponseHeader(&quot;Last-Modified&quot;) &amp;&amp; new Date(xhr.getResponseHeader(&quot;Last-Modified&quot;));
            if (responseLastModifiedDate &amp;&amp; isValidDate(responseLastModifiedDate)) {
                var metadata = property.getMetadata();
                var propertyLastModified = metadata.lastModified &amp;&amp; new Date(metadata.lastModified);
                if (!propertyLastModified || !isValidDate(propertyLastModified) || &#x2F;&#x2F; my last Modified date isn&#x27;t valid
                        Date.parse(responseLastModifiedDate) &gt; Date.parse(propertyLastModified)) { &#x2F;&#x2F;  or it is and it&#x27;s stale
                    property.setValue(jsonResponse);
                    metadata.lastModified = responseLastModifiedDate;
                } else {
                    &#x2F;&#x2F; fetch data hasn&#x27;t changed.
                }
            } else { &#x2F;&#x2F; no last Modified date in response header, always setValue
                property.setValue(jsonResponse);
            }
        }
    }

    &#x2F;*
     * Centralized place where all Model Events pass through.
     *&#x2F;
    var eventProxy = (function () {
        var eventQueue = [],
            state = {
                ACTIVE: &quot;active&quot;,
                TRANSACTION: &quot;transaction&quot;
            },
            eventType = {
                PROPERTY_CHANGE: &quot;propertyChange&quot;,
                MODEL_CHANGE: &quot;modelChange&quot;,
                CHANGE: &quot;change&quot;, &#x2F;&#x2F;special compound event that triggers propertyChange and bubble modelChange event. all other events do not bubble
                DESTROY: &quot;destroy&quot;,
                CHILD_CREATED: &quot;childCreated&quot;,
                CHILD_DESTROYED: &quot;childDestroyed&quot;
            },
            currentState = state.ACTIVE;

        var executedCallbacks = [];
        var callbackHashs = [];

        function _fireEvent(eventName, property, eventArg) {

            &#x2F;&#x2F; This weird executeCallback function is a bit more complicated than it needs to be but is
            &#x2F;&#x2F; used to get around the JSLint warning of creating a function within the while loop below
            var executeCallbacksFunction = function (changedProperty, listenerProperty, arg) {
                return function (callback) {
                    if (Model.TRANSACTION_OPTIONS.flattenCallbacks || Model.TRANSACTION_OPTIONS.flattenCallbacksByHash) {
                        var callbackExecuted = false;
                        if (Model.TRANSACTION_OPTIONS.flattenCallbacks) {
                            if (executedCallbacks.indexOf(callback) === -1) { &#x2F;&#x2F; Only call callback once
                                executedCallbacks.push(callback);
                                callback.call(listenerProperty, changedProperty, arg);
                                callbackExecuted = true;
                            }
                        }
                        if (Model.TRANSACTION_OPTIONS.flattenCallbacksByHash) {
                            if (!callback.hash || callbackHashs.indexOf(callback.hash) === -1) { &#x2F;&#x2F; Only call hash identified callback once
                                if (callback.hash) {
                                    callbackHashs.push(callback.hash);
                                }
                                if (!callbackExecuted) {
                                    callback.call(listenerProperty, changedProperty, arg);
                                    callbackExecuted = true;
                                }
                            }
                        }
                    } else {
                        callback.call(listenerProperty, changedProperty, arg);
                    }
                };
            };

            var propertyParent = property._parent;
            var eventListeners = property._eventListeners[eventName] || [];
            if (eventName === eventType.CHANGE) { &#x2F;&#x2F; Change is a special event it can propergate and it&#x27;s eventArg is the oldValue
                var allPropertyListeners = property._eventListeners.propertyChange.concat(property._eventListeners.modelChange);
                allPropertyListeners.forEach(
                    executeCallbacksFunction(property, property, eventArg)
                );

                while (propertyParent) {
                    propertyParent._eventListeners.modelChange.forEach( &#x2F;&#x2F; when we bubble the event we only notify modelListeners
                        executeCallbacksFunction(property, propertyParent, eventArg)
                    );
                    propertyParent = propertyParent._parent;
                }
            } else if (eventName === eventType.DESTROY) { &#x2F;&#x2F;destroy also notifies its parent childDestroyed listeners
                eventListeners.forEach(
                    executeCallbacksFunction(property, property, eventArg)
                );

                if (propertyParent) {
                    var childDestroyedListeners = propertyParent._eventListeners.childDestroyed || [];
                    childDestroyedListeners.forEach(
                        executeCallbacksFunction(property, propertyParent, eventArg)
                    );
                }
            } else {
                eventListeners.forEach(
                    executeCallbacksFunction(property, property, eventArg)
                );
            }
        }

        function fireEvent(eventName, property, customArg) {
            if (currentState === state.ACTIVE) { &#x2F;&#x2F; fire event now.
                _fireEvent(eventName, property, customArg);
            } else { &#x2F;&#x2F;place event on queue to be called at a later time.
                eventQueue.push({
                    eventName: eventName,
                    property: property,
                    customArg: customArg
                });
            }
        }

        function flushEventQueue() {

            executedCallbacks = []; &#x2F;&#x2F;reset state
            callbackHashs = [];
            if (Model.TRANSACTION_OPTIONS.suppressAllEvents) {
                &#x2F;&#x2F;discard all events
                eventQueue = [];
            } else if (Model.TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent) {
                var optimizedQueue = [];
                var seenProperties = [];
                for (var i = eventQueue.length - 1; i &gt;= 0; i -= 1) { &#x2F;&#x2F; iterate backwards since last events are most recent.
                    var eventProperty = eventQueue[i].property;
                    if (seenProperties.indexOf(eventProperty) === -1) {
                        &#x2F;&#x2F; Not seen yet add it.
                        seenProperties.push(eventProperty);
                        optimizedQueue.push(eventQueue[i]);
                    } else {
                        &#x2F;&#x2F;eventQueue[i] = null; &#x2F;&#x2F; null out event since it&#x27;s propertyChange is on the Queue Already
                    }
                }
                eventQueue = optimizedQueue;
            }

            eventQueue.forEach(function (event) {
                _fireEvent(event.eventName, event.property, event.customArg);
            });
            eventQueue = []; &#x2F;&#x2F;Queue has been flushed
        }

        function changeState(newState) {
            if (state[newState] !== currentState) {
                currentState = newState;
                if (newState === state.ACTIVE) {
                    flushEventQueue();
                }
            }
        }

        return {
            fireEvent: fireEvent,
            eventType: eventType,
            startTransaction: changeState.bind(null, state.TRANSACTION),
            endTransaction: changeState.bind(null, state.ACTIVE),
            inTransaction: function () {
                return currentState === state.TRANSACTION;
            }
        };
    }());

    &#x2F;*
     * An Observable Array is a wrapper around the javaScript Array primitive which will
     * trigger the correct events when any of it mutator methods are called. It is not
     * exposed outside of this file.
     *&#x2F;
    function ObservableArray(myProperty, values) {
        this._prop = myProperty;
        &#x2F;&#x2F;Array.call(this); &#x2F;&#x2F;not needed
        for (var i =0; i &lt; values.length; i++){
            var property = _createProperty(i, values[i], this, {});
            this.push(property);
        }
    }
    ObservableArray.prototype = Object.create(Array.prototype);

    ObservableArray.prototype.pop = function () {
        var args = Array.prototype.slice.call(arguments),
            element = Array.prototype.pop.apply(this, args);
        this._prop.trigger(eventProxy.eventType.CHILD_DESTROYED, element);
        return element;
    };
    ObservableArray.prototype.push = function () {
        var args = Array.prototype.slice.call(arguments),
            currentLength = this.length,
            pushArgs = [],
            property,
            i = 0;
        for (i = 0; i &lt; args.length; i++){
            property = args[i];
            if (!(property instanceof Property)) {
                property = _createProperty(currentLength + i, args[i], this, {});
            }
            pushArgs.push(property);
        }
        var newLength = Array.prototype.push.apply(this, pushArgs);

        this._prop.trigger(eventProxy.eventType.CHILD_CREATED, args);
        return newLength;
    };
    ObservableArray.prototype.reverse = function () {
        var args = Array.prototype.slice.call(arguments),
            oldValue = Array.prototype.slice.call(this);
        Array.prototype.reverse.apply(this, args);
        this._prop.trigger(eventProxy.eventType.PROPERTY_CHANGE, oldValue);
        return this;
    };
    ObservableArray.prototype.shift = function () {
        var args = Array.prototype.slice.call(arguments),
            element = Array.prototype.shift.apply(this, args);
        this._prop.trigger(eventProxy.eventType.CHILD_DESTROYED, element);
        return element;
    };
    ObservableArray.prototype.sort = function () {
        var args = Array.prototype.slice.call(arguments),
            oldValue = Array.prototype.slice.call(this);
        Array.prototype.sort.apply(this, args);
        this._prop.trigger(eventProxy.eventType.PROPERTY_CHANGE, oldValue);
        return this;
    };
    ObservableArray.prototype.splice = function () {
        &#x2F;&#x2F; A little more difficult!!
        var args = Array.prototype.slice.call(arguments),
            removed = Array.prototype.splice.apply(this, args);
        if (removed.length &gt; 0) {
            this._prop.trigger(eventProxy.eventType.CHILD_DESTROYED, removed);
        }
        this._prop.trigger(eventProxy.eventType.CHILD_CREATED); &#x2F;&#x2F; TODO use count to determin if should be called
        return removed;
    };
    ObservableArray.prototype.unshift = function () {
        var args = Array.prototype.slice.call(arguments),
            newElements = Array.prototype.slice(arguments),
            newLength = Array.prototype.unshift.apply(this, args);
        this._prop.trigger(eventProxy.eventType.CHILD_CREATED, newElements);
        return newLength;
    };

    &#x2F;**
     * A Property is a name value pair belonging to a Model.
     *
     * @class Property
     * @constructor
     * @private used internally by the Model.prototype.createProperty method.
     *
     * @param {[String]} name    The name of the property
     * @param {[String, Boolean, Number, null, Date, Function, Object]} value   The Property Value
     * @param {[Model]} parent  The parent property
     * @param {[Object]} metadata The metadata associated with the property. You can put any metadata you want. However the following keys have special meaning and are reserved for use by the framework.
     *                         validator - a function to validate if the new value is valid before it is assigned.
     *                         url - the resource this model should use to get it&#x27;s value. Resource must return json. *Must be used with refreshRate*
     *                         refreshRate - the interval used to query the url for changes. must be &gt; 0. minimal value used is 100. -1 indicates to only fetch value once. *Must be used with url*
     *&#x2F;
    function Property (name, value, parent, metadata) {

        var myName = &quot;&#x2F;&quot; + name;
        if (parent) {
            myName = parent.getName() + myName;
        }

        Object.defineProperty(this, &quot;_name&quot;, {
            value: myName,
            enumerable: false
        });

        Object.defineProperty(this, &quot;_parent&quot;, {
            value: parent,
            enumerable: false
        });

        Object.defineProperty(this, &quot;_metadata&quot;, {
            value: metadata || {},
            enumerable: false
        });

        Object.defineProperty(this, &quot;_eventListeners&quot;, {
            value: { &#x2F;&#x2F;map of eventName to listener array. The following are modeljs Events
                propertyChange: [],
                modelChange: [], &#x2F;&#x2F;model &quot;children&quot; changed come from property change and listenToChildren true.
                childCreated: [],
                childDestroyed: [], &#x2F;&#x2F; child destroyed comes from destroy
                destroy: []
            },
            enumerable: false
        });

        var myValue = value;
        &#x2F;&#x2F;make sure value is valid
        if (!this.validateValue(myValue)) {
            myValue = undefined;
        }

        Object.defineProperty(this, &quot;_myValue&quot;, {
            value: myValue,
            enumerable: false,
            writable: true
        });
    }

    &#x2F;**
     * Gets the value of the property.
     *
     * @method  getValue
     *
     * @return {[String, Boolean, Number, null, Date, Function]} The value of the property
     *&#x2F;
    Property.prototype.getValue = function () {
        return this._myValue;
    };

    &#x2F;**
     * Return the formatted value calculated by asking the Model.Formatter to format the value of this.
     *
     * @method getFormattedValue
     *
     * @return {any} The formatted Value
     *&#x2F;
    Property.prototype.getFormattedValue = function () {
        if (isFunction(Model.Formatter)) {
            return Model.Formatter.call(this, this.getValue());
        }
        return this.getValue();
    };

    &#x2F;**
     * The fully qualified name of this. The name is calculated by concatenating the name
     * of the parent, &quot;&#x2F;&quot;, and name of this. To create a named root pass in the name option key
     * to the Model Constructor.
     *
     * @example
     *     defaultModel.getName();              &#x2F;&#x2F; returns &quot;&#x2F;root&quot;
     *     defaultModel.property1.getName();    &#x2F;&#x2F; returns &quot;&#x2F;root&#x2F;property1&quot;
     *     namedRoot.property1.getName();       &#x2F;&#x2F; returns &quot;&#x2F;customName&#x2F;property1&quot;
     * For more examples see:  &lt;b&gt;testGetNameMethod&lt;&#x2F;b&gt;
     *
     * @method  getName
     *
     * @return {String} The fully qualified name of this.
     *&#x2F;
    Property.prototype.getName = function () {
        return this._name;
    };

    &#x2F;**
     * Called upon a property or Model to set it&#x27;s Value. If the setValue is the same as the current value,
     * nothing will happen and no change events will be fired. If the value is different it must pass
     * the validator if there is one.  If it does pass the validator and the value is changed, all registered
     * listeners will be notified unless the suppressNotifications option indicates otherwise.
     *
     * @example
     * For more examples see:  &lt;b&gt;testPrimitiveSetGet&lt;&#x2F;b&gt;, &lt;b&gt;testComplexChangePropertyValue&lt;&#x2F;b&gt; and &lt;b&gt;testSuppressNotifications&lt;&#x2F;b&gt;
     *
     * @method setValue
     * @for Property
     *
     * @param  {[String, Boolean, Number, null, Date, Function, Object]} newValue The Value you want to assign to the Property.
     * @param  {[Boolean]} suppressNotifications? Indicating if listeners should be notified of change.
     *
     * @return {[string, boolean, number, null, function, object]}          The resulting value. If the operation was successful this will be the passed in value otherwise it will be the existing one.
     *&#x2F;
    Property.prototype.setValue = function (value, suppressNotifications) {
        var newValue = value;

        if (newValue instanceof Property || Model.isArray(value)) {
            &#x2F;&#x2F; this is misleading syntax because other property attributes are not copied like _listener and _parent
            &#x2F;&#x2F; so prevent it and provide alternate.
            log(&#x27;error&#x27;, &quot;Incorrect Syntax: use setValue([property|model].getValue()) instead&quot;);
            return;
        }

        &#x2F;&#x2F; Note: this disallows setting a property to undefined. Only when it&#x27;s first created can it be undefined.
        if (newValue !== undefined &amp;&amp; newValue !== this._myValue) {

            if (!this.hasValidator() || this.validateValue(newValue)) {
                var oldValue = this._myValue;

                if (isObject(newValue)) {
                    if (!(this instanceof Model)) {
                        log(&#x27;error&#x27;, &quot;Not Supported: Can&#x27;t set the Model value to a property. Delete the model and use createProperty&quot;);
                        return;
                    } else {
                        &#x2F;&#x2F;This model need to be set to the newValue
                        if (this.merge(newValue, false)) {
                            this._myValue = newValue; &#x2F;&#x2F;set Value if successful
                        }
                    }
                } else if (Array.isArray(newValue)) { &#x2F;&#x2F; newValue is an Array
                    if (!Model.isArray(this)) {
                        log(&#x27;error&#x27;, &quot;Not Supported: Can not set a non-Array Property to an Array. Delete the property and use createProperty passing it the array&quot;);
                        return;
                    } else {
                        if (this.length &gt; newValue.length) { &#x2F;&#x2F;remove excess
                            this.splice(newValue.length, this.length - newValue.length);
                        }
                        for (var i = 0; i &lt; newValue.length; i++) {
                            if (this[i]) {
                                this[i].setValue(newValue[i]);
                            } else {
                                this.push(newValue[i]); &#x2F;&#x2F; add extra
                            }
                        }
                    }
                } else { &#x2F;&#x2F; newValue is a primative (non-object &amp;&amp; non-Array)
                    if (this instanceof Model) {
                        log(&#x27;error&#x27;, &quot;Not Supported: Can&#x27;t set a Property value to a model. Delete the property and use createProperty&quot;);
                        return;
                    } else {
                        this._myValue = newValue;
                    }
                }

                if (!suppressNotifications) {
                    eventProxy.fireEvent(eventProxy.eventType.CHANGE, this, oldValue);
                }
            }
        }
        return this._myValue;
    };

    &#x2F;**
     * Registers a callback function with the change event of this.  When the callback is executed it
     * will have it&#x27;s &#x27;this&#x27; context bound to this (ie. the property listening to the event). The first argument
     * will be the property that triggered the event. The final argument be the oldValue before it
     * was changed.
     *
     * @example
     *     model.onchange(callback, {listenToChildren: true}); &#x2F;&#x2F;listens to change events on entire model
     *     model.property1.onchange(callback) &#x2F;&#x2F;listen to change on property1 only
     *     model.subModel.onchange(callback) &#x2F;&#x2F;listen to change on subModel only. (ie. via model.subModel.setValue(..))
     * For more examples see:  &lt;b&gt;testOnChangeCallbackWhenSettingToSameValue&lt;&#x2F;b&gt; and &lt;b&gt;testBubbleUpEvents&lt;&#x2F;b&gt;
     *
     * @method  onChange
     *
     * @param {Function} callback The function to be called if the value of this changes. The callback function will be passed the following arguments (oldValue, newValue, propertyName)
     * @param {Boolean}   listenToChildren? Registers the callback with sub property changes as well.
     *&#x2F;
    Property.prototype.onChange = function (callback, listenToChildren) {
        if (!isFunction(callback)) {
            log(&#x27;warn&#x27;, &quot;Incorrect Syntax: callback must be a function&quot;);
            return;
        }
        if (listenToChildren) {
            this._eventListeners.modelChange.push(callback);
        } else {
            this._eventListeners.propertyChange.push(callback);
        }
        return this;
    };

    &#x2F;**
     * Removes the property and its children if any from the Model. This will fire the &#x27;destroy&#x27; event on this and
     * the &#x27;childDestroyed&#x27; event on the parent.
     *
     * @method  destroy
     *
     * @return {Property}   The deleted Property.
     *&#x2F;
    Property.prototype.destroy = function () {
        var myName = this.getName().substring(this.getName().lastIndexOf(&#x27;&#x2F;&#x27;) + 1);
        delete this._parent[myName];

        eventProxy.fireEvent(eventProxy.eventType.DESTROY, this);

        return this;
    };

    Property.prototype.onDestroy = function (callback) {
        return this.on(eventProxy.eventType.DESTROY, callback);
    };

    &#x2F;**
     * Triggers the given event on this. Passing the optional argument.
     *
     * @method  trigger
     *
     * @param  {String} eventName The name of the event.
     * @param  {[string, boolean, number, null, Date, function, object]} eventArg? An optional parameter to pass to the event handler
     * @return {Property}           Returns this for Object chaining.
     *&#x2F;
    Property.prototype.trigger = function (eventName, eventArg) {
        &#x2F;&#x2F;Should this restrict custom types
        eventProxy.fireEvent(eventName, this, eventArg);
        return this;
    };

    &#x2F;**
     * Registers the given callback with the given events on this. When the callback is executed it
     * will have it&#x27;s &#x27;this&#x27; context bound to this (ie. the property listening to the event). The first argument
     * will be the property that triggered the event. In most cases these are the same property,
     * unless the event is bubbling up the tree. The final argument is optional and varies depending on
     * event type.
     *
     * @method  on
     *
     * @param  {String} events     One or more space seperated eventNames
     * @param  {Function} callback  The function to execute when the given event is triggered
     * @return {Property}          Returns this for Object chaining.
     *&#x2F;
    Property.prototype.on = function (events, callback) {
        if (!isFunction(callback)) {
            log(&#x27;warn&#x27;, &quot;Incorrect Syntax: callback must be a function&quot;);
            return;
        }
        &#x2F;&#x2F;test Callback is a function
        var eventNames = events.split(&#x27; &#x27;);
        eventNames.forEach(function (eventName) {
            if (!this._eventListeners[eventName]) {
                this._eventListeners[eventName] = [];
            }
            this._eventListeners[eventName].push(callback);
        }, this);

        return this;
    };

    &#x2F;**
     * Removes all instances of the given callback with the given events on this.
     *
     * @method off
     *
     * @param  {String} events  One or more space seperated eventNames
     * @param  {Function} callback The function to remove
     * @return {Property}         Returns this for Object chaining.
     *&#x2F;
    Property.prototype.off = function (events, callback) {
        if (!isFunction(callback)) {
            log(&#x27;warn&#x27;, &quot;Incorrect Syntax: callback must be a function&quot;);
            return;
        }
        var eventNames = events.split(&#x27; &#x27;);
        eventNames.forEach(function (eventName) {
            if (this._eventListeners[eventName]) {
                this._eventListeners[eventName] = this._eventListeners[eventName].filter(function (element, index, array) {
                    return element !== callback;
                });
            }
        }, this);

        return this;
    };

    &#x2F;**
     * Retrieves the metadata associated with this. The metadata is persisted with the json when you
     * pass true to the toJSON method (eg. this.toJSON(true)). Likewise the metadata will be restored
     * when creating a model from the very same json. Note: the modeljs framework uses the metadata to
     * store attributes associated the properties that is uses. As a result the following keys have
     * special meaning. &lt;b&gt;[validator, name, url, refreshRate, isJSONPurl, doNotPresist ]&lt;&#x2F;b&gt;
     *
     * For example see: &lt;b&gt;testGetMetadataMethod&lt;&#x2F;b&gt;
     *
     * @method  getMetadata
     *
     * @return {Object} A map of metadata properties associated with this.
     *&#x2F;
    Property.prototype.getMetadata = function () {
        return this._metadata; &#x2F;&#x2F;TODO should I return a defensive copy?
    };

    &#x2F;**
     * Determine if this has a validation function associated with it.
     *
     * @example
     * For examples see:  &lt;b&gt;testPropertyValidationFunction&lt;&#x2F;b&gt;
     *
     * @method hasValidator
     *
     * @return {Boolean} True if this has a validator associated with it. False otherwise.
     *&#x2F;
    Property.prototype.hasValidator = function () {
        return isFunction(this._metadata.validator);
    };

   &#x2F;**
     * Determines if the given value will pass the validation function of this.
     *
     * @example
     * For examples see:  &lt;b&gt;testPropertyValidationFunction&lt;&#x2F;b&gt;
     *
     * @method  validateValue
     *
     * @param  {[String, Boolean, Number, null, Date, Function, Object]} value A value to test against the validation function if it exists.
     * @return {Boolean}      The result of passing value against the validation function if it exists. True otherwise.
     *&#x2F;
    Property.prototype.validateValue = function (value) {
        if (this.hasValidator()) {
            return this._metadata.validator(value);
        }
        return true;
    };
    &#x2F;&#x2F;don&#x27;t want a set validator function.

    var arrayGetValue = function () {
        var value = [],
            i = 0;
        for (i = 0; i &lt; this.length; i++) {
            value[i] = this[i].getValue();
        }
        return value;
    };

    var arraySetValueAt = function (index, value, metadata) {
        this[index] = _createProperty(index, value, this, metadata || {});
    };

    function createArrayPrototype(isA, inherits) {
        var proto = Object.create(isA);
        for (var i in inherits) {
            if (inherits.hasOwnProperty(i)) {
                proto[i] = inherits[i];
            }
        }
        &#x2F;&#x2F; array&#x27;s getValue implementation is different
        proto[&quot;getValue&quot;] = arrayGetValue;
        proto[&quot;setValueAt&quot;] = arraySetValueAt;

        return proto;
    }

    function ArrayProperty(name, value, parent, metadata) {
        Property.call(this, name, value, parent, metadata);
        ObservableArray.call(this, this, value);
    }
    ArrayProperty.prototype = createArrayPrototype(ObservableArray.prototype, Property.prototype);

   &#x2F;**
     * The model Object that wraps the JSON.
     *
     * @example
     * For examples see: &lt;b&gt;testPrimitiveSaveLoad&lt;&#x2F;b&gt;,  &lt;b&gt;testObjectsSaveLoad&lt;&#x2F;b&gt;, &lt;b&gt;testComplexSaveLoad&lt;&#x2F;b&gt;
     * &lt;b&gt;testGetNameMethod&lt;&#x2F;b&gt; and &lt;b&gt;testSaveLoadWithMetaData&lt;&#x2F;b&gt;
     *
     * @class Model
     * @constructor
     * @extends Property
     *
     * @param {Object} json?    The json object to be modeled.
     * @param {Object} metadata? May contain the following:
     *                         name - name of the Model, defaults to &quot;root&quot;
     *                         *plus any properties accepted by the createProperty method metadata argument or
     *                          additional data you want stored in the metadata.
     *&#x2F;
    function Model(json, metadata, parent) {
        var jsonModel = json || {},
            modelMetadata = metadata || {},
            modelName = (modelMetadata.name || &quot;root&quot;),
            modelParent = parent || null;

        if (modelMetadata.name) { &#x2F;&#x2F; name is not part of the metadata.
            delete modelMetadata.name;
        }

        &#x2F;&#x2F;A Model is in itself a Property so lets call our supers constructor
        Property.call(this, modelName, jsonModel, modelParent, modelMetadata);

        if (this.validateValue(json)) {

            for (var name in jsonModel) {
                if (name.match(Model.PROPERTY_METADATA_SERIALIZED_NAME_REGEX)) { &#x2F;&#x2F; skip special meta data properties
                    continue;
                }

                var value = jsonModel[name];
                var propertyMetadata = json[name + Model.PROPERTY_METADATA_SERIALIZED_NAME_SUFFIX];


                this.createProperty(name, value, propertyMetadata);
            }
        }
    }
    Model.prototype = Object.create(Property.prototype);

    &#x2F;**
     * Determins if the parameter passed in is an modeljs Array Property.
     *
     * @static
     * @method isArray
     *
     * @param  {Property}  property  Property to test whether or not it is an Array Property.
     * @return {Boolean}          true if the Property is an Array Property, false otherwise
     *&#x2F;
    Model.isArray = function (property) {
        return (property instanceof ArrayProperty);
    };

    Model.isProperty = function (property) {
        return Model.isArray(property) || ((property instanceof Property) &amp;&amp; !(property instanceof Model));
    };

    Model.PROPERTY_METADATA_SERIALIZED_NAME_SUFFIX = &quot;__modeljs__metadata&quot;;
    Model.PROPERTY_METADATA_SERIALIZED_NAME_REGEX = &#x2F;__modeljs__metadata$&#x2F;;

    &#x2F;**
     * Gets the value associated with the Model. This will be a json Object.
     *
     * @method  getValue
     *
     * @return {Object} The json Object represented by the model
     *&#x2F;
    Model.prototype.getValue = function () {
        return this.toJSON();
    };

    var MIN_MODEL_REFRESH_RATE = 100;
    function _createProperty (name, value, parent, metadata) {
        if (value instanceof Property || Model.isArray(value)) {
            log(&#x27;error&#x27;, &quot;Unsupported Operation: Try passing the Model&#x2F;Properties value instead&quot;);
            return;
        } else if (Array.isArray(value)) {
            return new ArrayProperty(name, value, parent, metadata);
        } else if (isObject(value)) {
            var modelMetadata = metadata || {};
            modelMetadata.name = name;
            var model = new Model(value, modelMetadata, parent);
            if (modelMetadata.url &amp;&amp; modelMetadata.refreshRate) {
                if (modelMetadata.refreshRate === -1){
                    makeRemoteRequest(model);
                } else {
                    var interval = Math.max(MIN_MODEL_REFRESH_RATE, modelMetadata.refreshRate);
                    var intervalId = setInterval(makeRemoteRequest.bind(null, model), interval);
                    model.getMetadata().intervalId = intervalId;
                }
            }
            return model;
        } else {
            return new Property(name, value, parent, metadata);
        }
    }

    &#x2F;**
     * Creates the property with the given name on this. This will fire the childCreated event on the parent. The
     * metadata can contain custom keys or any of the special keys below.
     *
     * @example
     *     var model = new Model();
     *     model.createProperty(&quot;number&quot;, 1) &#x2F;&#x2F; a simple property (model.number)
     *     .createProperty(&quot;subModel&quot;, { &#x2F;&#x2F; a property that is a subModel (model.subModel and model.subModel.str)
     *         str: &quot;stringProperty&quot;
     *     })
     *     .createProperty(&quot;positiveNumber&quot;, 2, { &#x2F;&#x2F; a property with a positiveNumber validator and a custom attribute
     *         validator: function (value) {
     *             return value &gt; 0;
     *         },
     *         customMetadata: &quot;this Property is special&quot;
     *     }),
     *     .createProperty (&quot;remoteModel&quot;, {prop1: &quot;defaultValue&quot;}, { &#x2F;&#x2F; a remote model populated via the twitter rest api.
     *         url: &quot;http:&#x2F;&#x2F;search.twitter.com&#x2F;search.json?q=tennis&amp;callback=$jsonpCallback&quot;,
     *         doNotPresist: true,
     *         refreshRate: -1, &#x2F;&#x2F; -1 means fetch once.
     *         isJSONPurl: true
     *     }); &#x2F;&#x2F; Note the method chaining.
     *
     * For examples see: &lt;b&gt;testModelCreationUsingCreatePropertyMethod&lt;&#x2F;b&gt;
     *
     * @method  createProperty
     *
     * @param {String} name    Name of the property
     * @param {[String, Boolean, Number, null, Date, Function, Object]} value   Property value
     * @param {[Object]} metadata? A hash of metadata associated with the property. You can put any metadata you want. However the following keys have special meaning and are reserved for use by the framework.
     *                         &lt;ul&gt;&lt;li&gt;
     *                             &lt;b&gt;validator&lt;&#x2F;b&gt; {Function} - a function to validate if the new value is valid before it is assigned.
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;url&lt;&#x2F;b&gt; {String} - the resource this model should use to get it&#x27;s value. Resource must return json. *Must be used with refreshRate*
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;refreshRate&lt;&#x2F;b&gt; {Number} - the interval used to query the url for changes. must be &gt; 100 or -1. -1 indicates to only fetch value once. *Must be used with url*
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;isJSONPurl&lt;&#x2F;b&gt; {Boolean} - if true will use JSONP to fetch the data. The url provided must have the string &quot;$jsonpCallback&quot; where the jsonp callback function should be inserted.
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;doNotPresist&lt;&#x2F;b&gt; {Boolean} - will nullify the value of the property when toJSON is called. For Object type the value will be and empty object. For any other type the value will be null.
     *                         &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;
     *
     * @return {Model}         Returns this for method chaining
     *&#x2F;
    Model.prototype.createProperty = function createProperty(name, value, metadata) {

        if (value instanceof Property || Model.isArray(value)) {
            log(&#x27;error&#x27;, &quot;Unsupported Operation: Try passing the Model&#x2F;Properties value instead&quot;);
            return;
        }
        this[name] = _createProperty(name, value, this, metadata);
        this.trigger(eventProxy.eventType.CHILD_CREATED, this[name]);
        return this;
    };

    &#x2F;**
     * Clones the Model rooted at this keeping all metadata that exist, but not keeping any event listeners.
     * The name of all properties are adjusted to reflect it&#x27;s new root.
     *
     * @example
     *     var newModel = model.clone(); &#x2F;&#x2F; clone root model
     *     var clonedSubModel = model.subModel.clone(); &#x2F;&#x2F; clone subModel
     * For more examples: &lt;b&gt;testModelClone&lt;&#x2F;b&gt;
     *
     * @method  clone
     *
     * @return {Model}  Returns a new Model object rooted at this, keeping any metadata but no event listeners.
     *&#x2F;
    Model.prototype.clone = function () {
        var myName = this.getName();
        var options = {
            name: myName.substring(myName.lastIndexOf(&quot;&#x2F;&quot;) + 1),
            validator: this._metadata.validator
        };
        return new Model(this.toJSON(true), options);
    };

    function mergeLoop(model, json, doModification, keepOldProperties) {

        for (var name in json) {
            var value = json[name];
            if (model[name]) {
                if (isObject(value)) { &#x2F;&#x2F; right hand side is an object
                    if (model[name] instanceof Model) { &#x2F;&#x2F; left is and Model. -&gt; merging objects
                        var successful = mergeLoop(model[name], value, doModification, keepOldProperties);
                        if (!successful) {
                            return false;
                        }
                    } else {
                        &#x2F;&#x2F; Trying to assign a model to a property. This will fail.
                        return false;
                    }

                } else { &#x2F;&#x2F; right hand side is not an object.
                    if (Model.isProperty(model[name])) { &#x2F;&#x2F; left is a Property -&gt; merging properties
                        if (doModification) {
                            model[name].setValue(value);
                        }
                    } else {
                        &#x2F;&#x2F; Trying to assign a property to a Model. This will fail.
                        return false;
                    }
                }
            } else { &#x2F;&#x2F;create new property
                if (doModification) {
                    model.createProperty(name, value);
                }
            }
        }

        &#x2F;&#x2F; delete properties that are not found in json
        if (!keepOldProperties &amp;&amp; doModification) {
            for (var modelProp in model) {
                if (!json[modelProp] &amp;&amp; &#x2F;&#x2F;property does exist in merge
                        model.hasOwnProperty(modelProp) &amp;&amp; (model[modelProp] instanceof Property || Model.isArray(model[modelProp]))&amp;&amp; modelProp !== &#x27;_parent&#x27;) { &#x2F;&#x2F; for ECMA backwards compatibility &#x27;_parent&#x27; must be filter since its non-enumerable
                    model[modelProp].destroy();
                }
            }
        }
        return true;
    }

    &#x2F;**
     * Preforms the merge operation on this. The merge operation will add properties that exist in the merged object
     * but not in this, remove those that are not found in the merged object (unless keepOldProperties is set to true)
     * and will call setValue for those that exist in both. Note the operation will log an error to the console, return
     * false, and not modify the object if any of the setValue operation are not valid. Not valid set operations inclded
     * those that try to set a value from a property to a model and vise versa.
     *
     * @example
     * For an example see: &lt;b&gt;testModelMergeMethod&lt;&#x2F;b&gt;
     *
     * @method  merge
     *
     * @param  {[Object]} json              The json object to have merged.
     * @param  {[Boolean]} keepOldProperties? True if you want to keep properties that exist in this but not in the passed in json, Otherwise they will be deleted. Defaults to false.
     * @return {Boolean}                   Returns true if merge was successful, false otherwise.
     *&#x2F;
    Model.prototype.merge = function (json, keepOldProperties) {
        &#x2F;&#x2F;will merge the properties in json with this. result will be the same as the Object extend.
        &#x2F;&#x2F;if a property exists in the model but not in the json it will only be kept if keepOldProperties is true.
        if (mergeLoop(this, json, false, keepOldProperties)) { &#x2F;&#x2F; check if merge will be successful
            Model.startTransaction();
            mergeLoop(this, json, true, keepOldProperties);
            Model.endTransaction();
            return true;
        } else {
            log(&#x27;error&#x27;, &quot;Merge operation Not Supported: An assignment was not valid. Model not modified&quot;);
            return false;
        }
    };


    &#x2F;**
     * Retrieves the json representation of this. This json representation can be used in the Model Constructor
     * to recreate the same Model object. If you use includeMetaData validator metadata will be included.
     * Properties that have the doNotPresist flag in it&#x27;s metadata will have it&#x27;s value nullified. This means
     * properties will have the value set to &#x27;undefined&#x27; while models will be set to an empty object ({}).
     *
     * @example
     * For an example see: &lt;b&gt;testSaveLoadWithMetaData&lt;&#x2F;b&gt; and &lt;b&gt;testDoNotPresist&lt;&#x2F;b&gt;
     *
     * @method  toJSON
     *
     * @param  {[Boolean]} includeMetaData? indicates if model meta data should be included in the returned JSON. Defaults to false.
     * @return {[Object]}                 The json representation of the Model.
     *&#x2F;
    Model.prototype.toJSON = function (includeMetaData) {
        var json = {};
        if (this._myValue === undefined) {
            return undefined;
        }

        for (var name in this) {
            if (this.hasOwnProperty(name) &amp;&amp; name !== &#x27;_parent&#x27;) {
                &#x2F;&#x2F; for ECMA backwards compatibility &#x27;_parent&#x27; must be filter since its non-enumerable. and would cause infinite recursion
                var property = this[name];
                if (property instanceof Model) {
                    if (property.getMetadata().doNotPresist) {
                        json[name] = {};
                    } else {
                        json[name] = property.toJSON(includeMetaData);
                    }
                    if (includeMetaData &amp;&amp; !isEmptyObject(property.getMetadata())) {
                        json[name + Model.PROPERTY_METADATA_SERIALIZED_NAME_SUFFIX] = property.getMetadata();
                    }
                } else if (Model.isProperty(property)) {
                    if (property.getMetadata().doNotPresist) {
                        json[name] = null;
                    } else {
                        json[name] = property.getValue();
                    }
                    if (includeMetaData &amp;&amp; !isEmptyObject(property.getMetadata())) {
                        json[name + Model.PROPERTY_METADATA_SERIALIZED_NAME_SUFFIX] = property.getMetadata();
                    }
                }
            }
        }
        return json;
    };

    &#x2F;**
     * A global formatter used to calculate the formatted value of a Property. If defined the function
     * will be called when getFormattedValue gets called. The function should accept the value to be formatted
     * as the first argument and expect &#x27;this&#x27; to be the Property. The formatter must be able to handle any
     * input type as a value.
     *
     * @example
     *     Model.Formatter = function (value) { &#x2F;&#x2F;makes all strings uppercase
     *         if (typeof value === &#x27;string&#x27;) {
     *             return value.toUpperCase();
     *         }
     *         return value;
     *     }
     *
     * @for  Model
     * @property  Formatter
     * @static
     *
     * @type {Function} A format function whose first argument is the value to be formatted
     * @return {any}    The formatted result
     *&#x2F;
    Model.Formatter = undefined;

    &#x2F;**
     * If logging is enabled any warning or incorrect uses of the api will result in output to the console
     * if it exists.
     *
     * @property isLoggingEnabled
     * @default false
     * @static
     * @type {Boolean} Indicates if Logging is enabled
     *&#x2F;
    Model.enableLogging = false;

    &#x2F;**
     * TODO figure out how I want to expose this.
     * Hence the no documentation.
     *
     *&#x2F;
    Model.find = function (model, propertyName) {
        var modelName = model.getName();
        var modelParts = modelName.split(&#x27;&#x2F;&#x27;);
        var propertyParts = propertyName.split(&#x27;&#x2F;&#x27;);
        var diff = &quot;&quot;;

        if (modelParts[0] !== propertyParts[0]) {
            return null;  &#x2F;&#x2F;not part of same model
        }

        var i = 0;
        while (modelParts[i] === propertyParts[i] &amp;&amp; i &lt; propertyParts.length) {
            i++;
        }

        var j = i;
        var commonDenominator = model;
        for ( j = i; j &lt; modelParts.length; j++) {
            commonDenominator = commonDenominator._parent;
        }

        var prop = commonDenominator;
        for (var k = i; k &lt; propertyParts.length; k++) {
            prop = prop[propertyParts[k]];
        }
        return prop;
    };


   &#x2F;**
     * Begins a transaction. All events will be put into the queued. To be fired when endTransaction is called.
     *
     * @example
     * For an examples see &lt;b&gt;testModelTransactions&lt;&#x2F;b&gt;
     *
     * @for  Model
     * @method  startTransaction
     * @static
     *
     *&#x2F;
    Model.startTransaction = function () {
        eventProxy.startTransaction();
    };


    &#x2F;**
     * Ends the current transaction causing all queued up events to be fired according to the global eventOptization settings or the settings passed in if they exist.
     *
     * @example
     *     model.endTransaction(); &#x2F;&#x2F;uses settings found in Model.TRANSACTION_OPTIONS
     *     model.endTransaction({   &#x2F;&#x2F; override the Model.TRANSACTION_OPTIONS settings for this transaction
     *         fireOnlyMostRecentPropertyEvent: false,
     *         flattenCallbacks: true,
     *         flattenCallbacksByHash: true
     *     })
     * For more examples see: &lt;b&gt;testFlattenCallbacks&lt;&#x2F;b&gt;, &lt;b&gt;testFlattenCallbacksByHash&lt;&#x2F;b&gt;,
     *      &lt;b&gt;testModelEndTransactionWithOptions&lt;&#x2F;b&gt;
     *
     * @for     Model
     * @method  endTransaction
     * @static
     *
     * @param  {Object} options? A map of Model.TRANSACTION_OPTIONS options that you want overridden when clearing this transaction queue.
     *&#x2F;
    Model.endTransaction = function (options) {
        var originalTransactionOptions;

        if (options) { &#x2F;&#x2F; if option override global setting keeping them so they can be restored later
            originalTransactionOptions = JSON.parse(JSON.stringify(Model.TRANSACTION_OPTIONS));
            Model.TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent = !!options.fireOnlyMostRecentPropertyEvent;
            Model.TRANSACTION_OPTIONS.flattenCallbacks = !!options.flattenCallbacks;
            Model.TRANSACTION_OPTIONS.flattenCallbacksByHash = !!options.flattenCallbacksByHash;
        }

        eventProxy.endTransaction();

        if (options) { &#x2F;&#x2F;restore global settings
            Model.TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent = originalTransactionOptions.fireOnlyMostRecentPropertyEvent;
            Model.TRANSACTION_OPTIONS.flattenCallbacks = originalTransactionOptions.flattenCallbacks;
            Model.TRANSACTION_OPTIONS.flattenCallbacksByHash = originalTransactionOptions.flattenCallbacksByHash;
        }

    };

    &#x2F;**
     * Determines if you are currently in a start&#x2F;end transaction block.
     *
     * @example
     * For an examples see &lt;b&gt;testModelTransactions&lt;&#x2F;b&gt;
     *
     * @for  Model
     * @method  inTransaction
     * @static
     *
     * @return {[Boolean]} True if your in a transaction block, false otherwise.
     *&#x2F;
    Model.inTransaction = function() {
        return eventProxy.inTransaction();
    };

    Model.TRANSACTION_OPTIONS = {
        &#x2F;**
            Only fires the last event of a property during a transaction.
            @Example For an example see &lt;b&gt;testFireOnlyMostRecentPropertyEvent&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent
            @default false
            @static
            @type {boolean}
        *&#x2F;
        fireOnlyMostRecentPropertyEvent: false,
        &#x2F;**
            Will make sure a callback only gets called only once during a transaction. Even if registered with several properties.
            @Example For an example see &lt;b&gt;testFlattenCallbacks&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.flattenCallbacks
            @default false
            @static
            @type {boolean}
         **&#x2F;
        flattenCallbacks: false,
        &#x2F;**
            Will make sure callbacks identified by .hash only gets called only once during a transaction. Even if registered with several properties.
            @Example For an example see &lt;b&gt;testFlattenCallbacksByHash&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.flattenCallbacksByHash
            @default false
            @static
            @type {boolean}
        *&#x2F;
        flattenCallbacksByHash: false,
        &#x2F;**
            Will guarentee that no event are fired during a transaction
            @Example For an example see &lt;b&gt;testSuppressAllEvents&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.suppressAllEvents
            @default false
            @static
            @type {boolean
        *&#x2F;
        suppressAllEvents: false

    };
    Object.seal(Model.TRANSACTION_OPTIONS);

    var oldModel = globalNS.Model;
    &#x2F;**
     * Release control of the global window.Model variable restoring it to its previous value
     *
     * @Example
     *     &#x2F;&#x2F; window.Model is restore to previous value and localModel now holds the window.Model reference
     *     var localModel = window.Model.noConflict();
     * For an example see &lt;b&gt;testModelNoConflict&lt;&#x2F;b&gt;
     *
     * @for  Model
     * @method  noConflict
     * @static
     *
     * @return {[Model]} The window Model variable that was just released.
     *&#x2F;
    Model.noConflict = function () {
        globalNS.Model = oldModel;
        return this;
    };


   if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        define([], function () { 
            return Model;
        });
    } else if (typeof exports !== &#x27;undefined&#x27;) {
        if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
            exports = module.exports = Model;
        }
        exports.Model = Model;
    } else {
        &#x2F;** @global *&#x2F;
        window[&quot;Model&quot;] = Model;
    }

}(this)); &#x2F;&#x2F;this === window in the browser and GLOBAL in node
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
