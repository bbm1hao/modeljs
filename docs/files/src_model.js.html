<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\model.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/ArrayProperty.html">ArrayProperty</a></li>
            
                <li><a href="..&#x2F;classes/Model.html">Model</a></li>
            
                <li><a href="..&#x2F;classes/Property.html">Property</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Model.html">Model</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\model.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Model js - A simple javascript library for creating the Model part of a MVC application.
 * https:&#x2F;&#x2F;github.com&#x2F;dgeorges&#x2F;modeljs.git
 *
 * Copyright 2012, Daniel Georges
 * modeljs is distributed freely under a MIT licence
 *
 * @project modeljs
 * @author Daniel Georges
 * @version 1.0.0
 * @module Model
 *&#x2F;
(function (globalNS, undefined) { &#x2F;&#x2F;globalNS === window in the browser or GLOBAL in nodejs
    &quot;use strict&quot;;

    &#x2F;&#x2F; copied from underscorejs
    function isFunction(fn) {
        return !!fn &amp;&amp; Object.prototype.toString.call(fn) === &#x27;[object Function]&#x27;;
    }

    function isObject(obj) {
        return obj === new Object(obj) &amp;&amp; !isFunction(obj) &amp;&amp; !Array.isArray(obj) &amp;&amp; !(obj instanceof Date);
    }

    function isEmptyObject(obj) {
        if (Object.getOwnPropertyNames) { &#x2F;&#x2F; only exits on ECMAScript 5 compatible browsers
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isValidDate(d) {
        if (Object.prototype.toString.call(d) !== &quot;[object Date]&quot;) {
            return false;
        }
        return !isNaN(d.getTime());
    }

    function log(level, message) {
        &#x2F;&#x2F;Only log when enabled and console log method is available
        if (Model.enableLogging &amp;&amp; typeof globalNS.console === &#x27;object&#x27; &amp;&amp; globalNS.console[level]) {
            globalNS.console[level](message);
        }
    }

    var getXHRObject = (function () {
        if (globalNS.XMLHttpRequest) { &#x2F;&#x2F; Mozilla, Safari, ...
            return function () {
                return new XMLHttpRequest();
            };
        } else if (globalNS.ActiveXObject) { &#x2F;&#x2F; IE
            try {
                new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
                return function () {
                    return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
                };
            } catch (e1) {
                try {
                    new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
                    return function () {
                        return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
                    };
                } catch (e2) {
                    &#x2F;&#x2F;do nothing
                }
            }
        }

        log(&#x27;error&#x27;, &quot;Could not create an XMLHTTPRequestObject Remote Model requests will fail&quot;);
        return undefined;
    }());

    function makeJSONPRequest(url, id) {
        var scriptTag = document.createElement(&quot;SCRIPT&quot;);
        scriptTag.id = id;
        scriptTag.type = &#x27;text&#x2F;javascript&#x27;;
        scriptTag.src = url;
        document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptTag);
    }

    var callbackId = 0;
    function generateJSONPCallback(property) {
        var fnName = &quot;modeljsJSONPCallback&quot; + callbackId++;
        window[fnName] = function (property, json) { &#x2F;&#x2F;create global callback
            property.setValue(json);
            var scriptElement = document.getElementById(fnName);
            document.getElementsByTagName(&#x27;head&#x27;)[0].removeChild(scriptElement); &#x2F;&#x2F;remove callback script
            try {
                delete window[fnName]; &#x2F;&#x2F; remove global callback method
            } catch (e) {
                &#x2F;&#x2F; this seems to throw and exception in IE8 so we will release it get garbage collected.
                window[fnName] = undefined;
            }
        }.bind(null, property);
        return fnName;
    }

    function makeRemoteRequest(property) {
        var url = property.getMetadata().url;
        if (property.getMetadata().isJSONPurl) {
            var uniqueCallbackId = generateJSONPCallback(property);
            url = url.replace(&quot;$jsonpCallback&quot;, uniqueCallbackId);
            makeJSONPRequest(url, uniqueCallbackId);
        } else {
            var httpRequest = getXHRObject();
            httpRequest.onreadystatechange = retrieveRemoteRequest.bind(null, httpRequest, property);
            &#x2F;&#x2F;httpRequest.orgin = &quot;localhost:8080&quot;;
            &#x2F;&#x2F;httpRequest.setRequestHeader
            httpRequest.open(&#x27;GET&#x27;, url);
            httpRequest.send();
        }
    }

    function retrieveRemoteRequest(xhr, property, xhrProgressEvent) {
        if (xhr.readyState === 4) {

            if (xhr.status !== 200) {
                log(&#x27;warn&#x27;, &quot;Remote request for &quot; + property.getName() + &quot; failded due to return status of &quot; + xhr.status);
                if (property.getMetadata().refreshRate === -1) {
                    log(&#x27;warn&#x27;, &quot;Retrying remote request for &quot; + property.getName() + &quot; in 2 seconds&quot;);
                    setTimeout(makeRemoteRequest.bind(null, property), 2000);&#x2F;&#x2F; try again in 2 sec
                }
                return;
            }

            if (xhr.responseType !== &quot;json&quot; &amp;&amp; xhr.responseType !== &quot;&quot;) {
                log(&#x27;error&#x27;, &quot;Remote model (&quot; + property.getName() + &quot;) must return JSON. Not retrying.&quot;);
                return;
            }

            &#x2F;&#x2F;look into ArrayBuffer
            var jsonResponse = {};
            try {
                jsonResponse = JSON.parse(xhr.response);
            } catch (e) {
                log(&#x27;error&#x27;, &quot;Unable to parse remote Model request for &quot; + property.getName());
                return; &#x2F;&#x2F;should retry? makeRemoteRequest(property);
            }

            &#x2F;&#x2F;use response header Last-Modified time stamp to determine if we should call setValue
            var responseLastModifiedDate = xhr.getResponseHeader(&quot;Last-Modified&quot;) &amp;&amp; new Date(xhr.getResponseHeader(&quot;Last-Modified&quot;));
            if (responseLastModifiedDate &amp;&amp; isValidDate(responseLastModifiedDate)) {
                var metadata = property.getMetadata();
                var propertyLastModified = metadata.lastModified &amp;&amp; new Date(metadata.lastModified);
                if (!propertyLastModified || !isValidDate(propertyLastModified) || &#x2F;&#x2F; my last Modified date isn&#x27;t valid
                        Date.parse(responseLastModifiedDate) &gt; Date.parse(propertyLastModified)) { &#x2F;&#x2F;  or it is and it&#x27;s stale
                    property.setValue(jsonResponse);
                    metadata.lastModified = responseLastModifiedDate;
                } else {
                    &#x2F;&#x2F; fetch data hasn&#x27;t changed.
                }
            } else { &#x2F;&#x2F; no last Modified date in response header, always setValue
                property.setValue(jsonResponse);
            }
        }
    }

    &#x2F;*
     * Centralized place where all Model Events pass through.
     *&#x2F;
    var eventProxy = (function () {
        var eventQueue = [],
            state = {
                ACTIVE: &quot;active&quot;,
                TRANSACTION: &quot;transaction&quot;
            },
            currentState = state.ACTIVE;

        var executedCallbacks = [];
        var callbackHashs = [];

        function _fireEvent(eventName, property, eventArg) {

            &#x2F;&#x2F; This weird executeCallback function is a bit more complicated than it needs to be but is
            &#x2F;&#x2F; used to get around the JSLint warning of creating a function within the while loop below
            var executeCallbacksFunction = function (listenerProperty, changedProperty, arg) {
                return function (callback) {
                    if (Model.TRANSACTION_OPTIONS.flattenCallbacks || Model.TRANSACTION_OPTIONS.flattenCallbacksByHash) {
                        var callbackExecuted = false;
                        if (Model.TRANSACTION_OPTIONS.flattenCallbacks) {
                            if (executedCallbacks.indexOf(callback) === -1) { &#x2F;&#x2F; Only call callback once
                                executedCallbacks.push(callback);
                                callback.call(listenerProperty, changedProperty, arg);
                                callbackExecuted = true;
                            }
                        }
                        if (Model.TRANSACTION_OPTIONS.flattenCallbacksByHash) {
                            if (!callback.hash || callbackHashs.indexOf(callback.hash) === -1) { &#x2F;&#x2F; Only call hash identified callback once
                                if (callback.hash) {
                                    callbackHashs.push(callback.hash);
                                }
                                if (!callbackExecuted) {
                                    callback.call(listenerProperty, changedProperty, arg);
                                    callbackExecuted = true;
                                }
                            }
                        }
                    } else {
                        callback.call(listenerProperty, changedProperty, arg);
                    }
                };
            };

            &#x2F;&#x2F;new
            var eventListeners = property._eventListeners[eventName] || [];
            if (eventName === Model.Event.PROPERTY_CHANGE) {
                eventListeners = eventListeners.concat(property._eventListeners.change);
            } else if (eventName === Model.Event.MODEL_CHANGE) {
                eventListeners = eventListeners.concat(property._eventListeners.change);
            } else if (eventName === Model.Event.CHANGE) {
                eventListeners = eventListeners.concat(property._eventListeners.propertyChange);
            }

            &#x2F;&#x2F; update listeners registared for the event
            eventListeners.forEach(
                executeCallbacksFunction(property, property, eventArg)
            );

            &#x2F;&#x2F; propergate change up the stack for the following events by notifying all parent ModelChange listers registered.
            var propertyParent = property._parent;
            &#x2F;&#x2F;if (eventName === Model.Event.CHANGE || eventName === Model.Event.MODEL_CHANGE ||
            &#x2F;&#x2F;        eventName === Model.Event.CHILD_CREATED || eventName === Model.Event.CHILD_DESTROYED) {
                while (propertyParent) {
                    var parentListeners = propertyParent._eventListeners.modelChange.concat(propertyParent._eventListeners.change);
                    parentListeners.forEach( &#x2F;&#x2F; when we bubble the event we only notify modelListeners
                        executeCallbacksFunction(propertyParent, property, eventArg)
                    );
                    propertyParent = propertyParent._parent;
                }
            &#x2F;&#x2F;}
        }

        function fireEvent(eventName, property, customArg) {
            if (currentState === state.ACTIVE) { &#x2F;&#x2F; fire event now.
                _fireEvent(eventName, property, customArg);
            } else { &#x2F;&#x2F;place event on queue to be called at a later time.
                eventQueue.push({
                    eventName: eventName,
                    property: property,
                    customArg: customArg
                });
            }
        }

        function flushEventQueue() {

            executedCallbacks = []; &#x2F;&#x2F;reset state
            callbackHashs = [];
            if (Model.TRANSACTION_OPTIONS.suppressAllEvents) {
                &#x2F;&#x2F;discard all events
                eventQueue = [];
            } else if (Model.TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent) {
                var optimizedQueue = [];
                var seenProperties = [];
                for (var i = eventQueue.length - 1; i &gt;= 0; i -= 1) { &#x2F;&#x2F; iterate backwards since last events are most recent.
                    var eventProperty = eventQueue[i].property;
                    if (seenProperties.indexOf(eventProperty) === -1) {
                        &#x2F;&#x2F; Not seen yet add it.
                        seenProperties.push(eventProperty);
                        optimizedQueue.push(eventQueue[i]);
                    } else {
                        &#x2F;&#x2F;eventQueue[i] = null; &#x2F;&#x2F; null out event since it&#x27;s propertyChange is on the Queue Already
                    }
                }
                eventQueue = optimizedQueue;
            }

            eventQueue.forEach(function (event) {
                _fireEvent(event.eventName, event.property, event.customArg);
            });
            eventQueue = []; &#x2F;&#x2F;Queue has been flushed
        }

        function changeState(newState) {
            if (state[newState] !== currentState) {
                currentState = newState;
                if (newState === state.ACTIVE) {
                    flushEventQueue();
                }
            }
        }

        return {
            fireEvent: fireEvent,
            startTransaction: changeState.bind(null, state.TRANSACTION),
            endTransaction: changeState.bind(null, state.ACTIVE),
            inTransaction: function () {
                return currentState === state.TRANSACTION;
            }
        };
    }());

    &#x2F;*
     * An Observable Array is a wrapper around the javaScript Array primitive which will
     * trigger the correct events when any of it mutator methods are called. It is not
     * exposed outside of this file.
     *&#x2F;
    function ObservableArray(myProperty, values) {
        this._prop = myProperty;
        for (var i =0; i &lt; values.length; i++){
            this.push(values[i]);
        }
    }
    ObservableArray.prototype = Object.create(Array.prototype);

    ObservableArray.prototype.pop = function () {
        var args = Array.prototype.slice.call(arguments),
            element = Array.prototype.pop.apply(this, args);
        this._prop.trigger(Model.Event.CHILD_DESTROYED, element);
        return element;
    };
    ObservableArray.prototype.push = function () {
        var args = Array.prototype.slice.call(arguments),
            currentLength = this.length,
            pushedArgs = [],
            property,
            i = 0;
        for (i = 0; i &lt; args.length; i++){
            property = args[i];
            if (!(property instanceof Property)) {
                property = _createProperty(currentLength + i, args[i], this, {});
            }
            pushedArgs.push(property);
        }
        var newLength = Array.prototype.push.apply(this, pushedArgs);

        this._prop.trigger(Model.Event.CHILD_CREATED, pushedArgs);
        return newLength;
    };
    ObservableArray.prototype.reverse = function () {
        var args = Array.prototype.slice.call(arguments),
            oldValue = Array.prototype.slice.call(this);
        Array.prototype.reverse.apply(this, args);
        this._prop.trigger(Model.Event.CHANGE, oldValue);
        return this;
    };
    ObservableArray.prototype.shift = function () {
        var args = Array.prototype.slice.call(arguments),
            element = Array.prototype.shift.apply(this, args);
        this._prop.trigger(Model.Event.CHILD_DESTROYED, element);
        return element;
    };
    ObservableArray.prototype.sort = function () {
        var args = Array.prototype.slice.call(arguments),
            oldValue = Array.prototype.slice.call(this);
        Array.prototype.sort.apply(this, args);
        this._prop.trigger(Model.Event.CHANGE, oldValue);
        return this;
    };
    ObservableArray.prototype.splice = function () {
        var args = Array.prototype.slice.call(arguments),
            removed = Array.prototype.splice.apply(this, args);
        if (removed.length &gt; 0) {
            this._prop.trigger(Model.Event.CHILD_DESTROYED, removed);
        }
        if (args.length &gt; 2) { &#x2F;&#x2F; we are adding new elements
            var added = args.slice(2);
            this._prop.trigger(Model.Event.CHILD_CREATED, added); &#x2F;&#x2F; TODO use count to determin if should be called
        }
        return removed; &#x2F;&#x2F;splice returns array of removed elements
    };
    ObservableArray.prototype.unshift = function () {
        var args = Array.prototype.slice.call(arguments),
            newElements = Array.prototype.slice(arguments),
            newLength = Array.prototype.unshift.apply(this, args);
        this._prop.trigger(Model.Event.CHILD_CREATED, newElements);
        return newLength;
    };

    &#x2F;**
     * A Property is a name value pair belonging to a Model.
     *
     * @class Property
     * @constructor
     * @private used internally by the Model.prototype.createProperty method.
     *
     * @param {[String]} name    The name of the property
     * @param {[String, Boolean, Number, null, Date, Function, Object]} value   The Property Value
     * @param {[Model]} parent  The parent property
     * @param {[Object]} metadata The metadata associated with the property. You can put any metadata you want. However the following keys have special meaning and are reserved for use by the framework.
     *                         validator - a function to validate if the new value is valid before it is assigned.
     *                         url - the resource this model should use to get it&#x27;s value. Resource must return json. *Must be used with refreshRate*
     *                         refreshRate - the interval used to query the url for changes. must be &gt; 0. minimal value used is 100. -1 indicates to only fetch value once. *Must be used with url*
     *&#x2F;
    function Property (name, value, parent, metadata) {

        var myName = &quot;&#x2F;&quot; + name;
        if (parent) {
            myName = parent.getName() + myName;
        }

        Object.defineProperty(this, &quot;_name&quot;, {
            value: myName,
            enumerable: false
        });

        Object.defineProperty(this, &quot;_parent&quot;, {
            value: parent,
            enumerable: false
        });

        Object.defineProperty(this, &quot;_metadata&quot;, {
            value: metadata || {},
            enumerable: false
        });

        Object.defineProperty(this, &quot;_eventListeners&quot;, {
            value: { &#x2F;&#x2F;map of eventName to listener array. The following are modeljs Events
                propertyChange: [],
                modelChange: [],
                change: [],
                childCreated: [],
                childDestroyed: [],
                destroy: []
            },
            enumerable: false
        });

        var myValue = value;
        &#x2F;&#x2F;make sure value is valid
        if (!this.validateValue(myValue)) {
            myValue = undefined;
        }

        Object.defineProperty(this, &quot;_myValue&quot;, {
            value: myValue,
            enumerable: false,
            writable: true
        });
    }

    &#x2F;**
     * Gets the value of the property.
     *
     * @method  getValue
     *
     * @return {[String, Boolean, Number, null, Date, Function]} The value of the property
     *&#x2F;
    Property.prototype.getValue = function () {
        return this._myValue;
    };

    Property.prototype.toJSON = function () {
        if (this.getMetadata().doNotPersistValue || this.getMetadata().doNotPersist) {
            return undefined;
        }
        return this.getValue();
    };

    &#x2F;**
     * Return the formatted value calculated by passing this.getValue() to the this.getMetadata().Formatter function
     * if it exists. If the metadata Formatter does not exist it will fall back to the global Formatter located at
     * Model.Formatter. If that does not exist it will return this.getValue();
     *
     * @method getFormattedValue
     *
     * @return {any} The formatted Value
     *&#x2F;
    Property.prototype.getFormattedValue = function () {
        if (isFunction(this.getMetadata().Formatter)) {
            return this.getMetadata().Formatter(this.getValue());
        } else if (isFunction(Model.Formatter)) {
            return Model.Formatter.call(this, this.getValue());
        }
        &#x2F;&#x2F; default
        return this.getValue();
    };

    &#x2F;**
     * The fully qualified name of this. The name is calculated by concatenating the name
     * of the parent, &quot;&#x2F;&quot;, and name of this AKA the shortName. To create a named root pass in the name option key
     * to the Model Constructor.
     *
     * @example
     *     defaultModel.getName();              &#x2F;&#x2F; returns &quot;&#x2F;root&quot;
     *     defaultModel.property1.getName();    &#x2F;&#x2F; returns &quot;&#x2F;root&#x2F;property1&quot;
     *     namedRoot.property1.getName();       &#x2F;&#x2F; returns &quot;&#x2F;customName&#x2F;property1&quot;
     * For more examples see:  &lt;b&gt;testGetNameMethod&lt;&#x2F;b&gt;
     *
     * @method  getName
     *
     * @return {String} The fully qualified name of this.
     *&#x2F;
    Property.prototype.getName = function (shortName) {
        if (shortName) {
            return this._name.substring(this._name.lastIndexOf(&quot;&#x2F;&quot;) + 1);
        }
        return this._name;
    };

    &#x2F;**
     * The given name of the property.
     * @return {[String]} The given name of the property.
     *&#x2F;
    Property.prototype.getShortName = function () {
            return this._name.substring(this._name.lastIndexOf(&quot;&#x2F;&quot;) + 1);
    };


    &#x2F;**
     * Called to set the value of a property. If the setValue is the same as the current value,
     * nothing will happen and no change events will be fired. If the value is different it must pass
     * the validator if there is one.  If it does pass the validator and the value is changed, all registered
     * listeners will be notified unless the suppressNotifications option indicates otherwise.
     *
     * @example
     * For more examples see:  &lt;b&gt;testPrimitiveSetGet&lt;&#x2F;b&gt;, &lt;b&gt;testComplexChangePropertyValue&lt;&#x2F;b&gt; and &lt;b&gt;testSuppressNotifications&lt;&#x2F;b&gt;
     *
     * @method setValue
     * @for Property
     *
     * @param  {[String, Boolean, Number, null, Date, Function, Object]} newValue The Value you want to assign to the Property.
     * @param  {[Boolean]} suppressNotifications? indicates if listeners should be notified of change.
     *
     * @return {[this]} this for method chaining.
     *&#x2F;
    Property.prototype.setValue = function (value, suppressNotifications) {
        var newValue = value;
        &#x2F;&#x2F; Note: this disallows setting a property to undefined. Only when it&#x27;s first created can it be undefined.
        if (newValue !== undefined &amp;&amp; newValue !== this._myValue) {

            if (this.validateValue(newValue)) {
                var oldValue = this._myValue;

                this._myValue = newValue;

                if (!suppressNotifications) {
                    eventProxy.fireEvent(Model.Event.PROPERTY_CHANGE, this, oldValue);
                }
            }
        }
        return this;
    };

    &#x2F;**
     * Registers a callback function with the change event of this.  When the callback is executed it
     * will have it&#x27;s &#x27;this&#x27; context bound to this (ie. the property listening to the event). The first argument
     * will be the property that triggered the event. The final argument be the oldValue before it
     * was changed.
     *
     * @example
     *     model.onchange(callback, {listenToChildren: true}); &#x2F;&#x2F;listens to change events on entire model
     *     model.property1.onchange(callback) &#x2F;&#x2F;listen to change on property1 only
     *     model.subModel.onchange(callback) &#x2F;&#x2F;listen to change on subModel only. (ie. via model.subModel.setValue(..))
     * For more examples see:  &lt;b&gt;testOnChangeCallbackWhenSettingToSameValue&lt;&#x2F;b&gt; and &lt;b&gt;testBubbleUpEvents&lt;&#x2F;b&gt;
     *
     * @method  onChange
     *
     * @param {Function} callback The function to be called if the value of this changes. The callback function will be passed the following arguments (oldValue, newValue, propertyName)
     * @param {Boolean}   listenToChildren? Registers the callback with sub property changes as well.
     *&#x2F;
    Property.prototype.onChange = function (callback, listenToChildren) {
        if (!isFunction(callback)) {
            log(&#x27;warn&#x27;, &quot;Incorrect Syntax: callback must be a function&quot;);
            return;
        }
        if (listenToChildren) {
            this._eventListeners.change.push(callback);
        } else {
            this._eventListeners.propertyChange.push(callback);
        }
        return this;
    };

    &#x2F;**
     * Removes the property and its children if any from the Model. This will fire the &#x27;destroy&#x27; event on this and
     * the &#x27;childDestroyed&#x27; event on the parent.
     *
     * @method  destroy
     *
     * @param  {[Boolean]} suppressNotifications? indicates if listeners should be notified of destroy.
     * @return {Property}   The deleted Property.
     *&#x2F;
    Property.prototype.destroy = function (suppressNotifications) {
        var myName = this.getName().substring(this.getName().lastIndexOf(&#x27;&#x2F;&#x27;) + 1);
        delete this._parent[myName];

        if (!suppressNotifications) {
            this.trigger(Model.Event.DESTROY); &#x2F;&#x2F;equivlant since no event arg.
            this._parent.trigger(Model.Event.CHILD_DESTROYED, this);
        }
        return this;
    };

    Property.prototype.onDestroy = function (callback) {
        return this.on(Model.Event.DESTROY, callback);
    };

    Property.prototype.getRoot = function () {
        var ancestor = this._parent;
        while (ancestor._parent !== null) {
            ancestor = ancestor._parent;
        }
        return ancestor;
    };

    &#x2F;&#x2F; is this really needed?
    Property.prototype.getParent = function () {
        return this._parent;
    };

    &#x2F;**
     * Triggers the given event on this. Passing the optional argument.
     *
     * @method  trigger
     *
     * @param  {String} eventName The name of the event.
     * @param  {[string, boolean, number, null, Date, function, object]} eventArg? An optional parameter to pass to the event handler
     * @return {Property}           Returns this for Object chaining.
     *&#x2F;
    Property.prototype.trigger = function (eventName, eventArg) {
        &#x2F;&#x2F;Should this restrict custom types
        eventProxy.fireEvent(eventName, this, eventArg);
        return this;
    };

    &#x2F;**
     * Registers the given callback with the given events on this. When the callback is executed it
     * will have it&#x27;s &#x27;this&#x27; context bound to this (ie. the property listening to the event). The first argument
     * will be the property that triggered the event. In most cases these are the same property,
     * unless the event is bubbling up the tree. The final argument is optional and varies depending on
     * event type.
     *
     * @method  on
     *
     * @param  {String} events     One or more space seperated eventNames
     * @param  {Function} callback  The function to execute when the given event is triggered
     * @return {Property}          Returns this for Object chaining.
     *&#x2F;
    Property.prototype.on = function (events, callback) {
        if (!isFunction(callback)) {
            log(&#x27;warn&#x27;, &quot;Incorrect Syntax: callback must be a function&quot;);
            return;
        }
        &#x2F;&#x2F;test Callback is a function
        var eventNames = events.split(&#x27; &#x27;);
        eventNames.forEach(function (eventName) {
            if (!this._eventListeners[eventName]) {
                this._eventListeners[eventName] = [];
            }
            this._eventListeners[eventName].push(callback);
        }, this);

        return this;
    };

    &#x2F;**
     * Removes all instances of the given callback with the given events on this.
     *
     * @method off
     *
     * @param  {String} events  One or more space seperated eventNames
     * @param  {Function} callback The function to remove
     * @return {Property}         Returns this for Object chaining.
     *&#x2F;
    Property.prototype.off = function (events, callback) {
        if (!isFunction(callback)) {
            log(&#x27;warn&#x27;, &quot;Incorrect Syntax: callback must be a function&quot;);
            return;
        }
        var eventNames = events.split(&#x27; &#x27;);
        eventNames.forEach(function (eventName) {
            if (this._eventListeners[eventName]) {
                this._eventListeners[eventName] = this._eventListeners[eventName].filter(function (element, index, array) {
                    return element !== callback;
                });
            }
        }, this);

        return this;
    };

    &#x2F;**
     * Retrieves the metadata associated with this. The metadata is persisted with the json when you
     * pass true to the toJSON method (eg. this.toJSON(true)). Likewise the metadata will be restored
     * when creating a model from the very same json. Note: the modeljs framework uses the metadata to
     * store attributes associated the properties that is uses. As a result the following keys have special
     * meaning. &lt;b&gt;[validator, Fromatter, name, url, refreshRate, isJSONPurl, doNotPersist, doNotPersistValue, thin]&lt;&#x2F;b&gt;
     *
     * For example see: &lt;b&gt;testGetMetadataMethod&lt;&#x2F;b&gt;
     *
     * @method  getMetadata
     *
     * @return {Object} A map of metadata properties associated with this.
     *&#x2F;
    Property.prototype.getMetadata = function () {
        return this._metadata;
    };

    &#x2F;**
     * Determine if this has a validation function associated with it.
     *
     * @example
     * For examples see:  &lt;b&gt;testPropertyValidationFunction&lt;&#x2F;b&gt;
     *
     * @method hasValidator
     *
     * @return {Boolean} True if this has a validator associated with it. False otherwise.
     *&#x2F;
    Property.prototype.hasValidator = function () {
        return isFunction(this._metadata.validator);
    };

   &#x2F;**
     * Determines if the given value will pass the validation function of this.
     *
     * @example
     * For examples see:  &lt;b&gt;testPropertyValidationFunction&lt;&#x2F;b&gt;
     *
     * @method  validateValue
     *
     * @param  {[String, Boolean, Number, null, Date, Function]} value A value to test against the validation function if it exists.
     * @return {Boolean}      The result of passing value against the validation function if it exists. True otherwise.
     *&#x2F;
    Property.prototype.validateValue = function (value) {

        &#x2F;&#x2F; disallow values that are Model Property or PropertyArray objects
        if (value instanceof Property || Model.isArray(value)) {
            &#x2F;&#x2F; this is misleading syntax because other property attributes are not copied like _listener and _parent
            &#x2F;&#x2F; so prevent it and provide alternate. Maybe we could clone, but the suggested is basically a clone and more transparent.
            log(&#x27;error&#x27;, &quot;Incorrect Syntax: use setValue([property].getValue()) instead&quot;);
            return false;
        } else if (isObject(value) || Array.isArray(value)) { &#x2F;&#x2F; value is a primative (non-object &amp;&amp; non-Array). this must be as well.
            log(&#x27;error&#x27;, &quot;Not Supported: Can&#x27;t set a Property value to a model or Array. Delete the property and use createProperty&quot;);
            return false;
        }

        if (this.hasValidator()) {
            return this._metadata.validator(value);
        }
        return true;
    };


    function createArrayPrototype(isA, inherits) {
        var proto = Object.create(isA);
        for (var i in inherits) {
            if (inherits.hasOwnProperty(i)) {
                proto[i] = inherits[i];
            }
        }

        return proto;
    }

   &#x2F;**
     * The modeljs Object that extends a javaScript Array with Property methods.
     * Array function like push, pop etc... can be used.
     *
     * @example
     * For examples see: &lt;b&gt;testPrimitiveSaveLoad&lt;&#x2F;b&gt;,  &lt;b&gt;testObjectsSaveLoad&lt;&#x2F;b&gt;, &lt;b&gt;testComplexSaveLoad&lt;&#x2F;b&gt;
     * &lt;b&gt;testGetNameMethod&lt;&#x2F;b&gt; and &lt;b&gt;testSaveLoadWithMetaData&lt;&#x2F;b&gt;
     *
     * @class ArrayProperty
     * @constructor
     * @extends Property
     *
     *&#x2F;
    function ArrayProperty(name, value, parent, metadata) {
        Property.call(this, name, value, parent, metadata);
        ObservableArray.call(this, this, value);
    }
    ArrayProperty.prototype = createArrayPrototype(ObservableArray.prototype, Property.prototype);

    &#x2F;**
     * Called to set the value of a ArrayProperty. If the setValue is the same as the current value,
     * nothing will happen and no change events will be fired. If the value is different it must pass
     * the validator if there is one.  If it does pass the validator and the value is changed, all registered
     * listeners will be notified unless the suppressNotifications option indicates otherwise.
     *
     * @method  setValue
     * @for  ArrayProperty
     *
     * @param  {[Array]} newValue The Value you want to assign to this.
     * @param  {[Boolean]} suppressNotifications? indicates if listeners should be notified of change.
     *
     * @return {[this]} this for method chaining.
     *&#x2F;
    ArrayProperty.prototype.setValue = function (value, suppressNotifications) {
        var newValue = value;
        &#x2F;&#x2F; Note: this disallows setting a property to undefined. Only when it&#x27;s first created can it be undefined.
        if (newValue !== undefined &amp;&amp; newValue !== this._myValue) { &#x2F;&#x2F;!== needs to be done another way.

            if (this.validateValue(newValue)) {
                var oldValue = this._myValue;
                if (this.length &gt; newValue.length) { &#x2F;&#x2F;remove excess
                    this.splice(newValue.length, this.length - newValue.length);
                }
                for (var i = 0; i &lt; newValue.length; i++) {
                    if (this[i]) {
                        this[i].setValue(newValue[i], suppressNotifications);
                    } else {
                        this.push(newValue[i]); &#x2F;&#x2F; add extra
                    }
                }
                &#x2F;&#x2F; fix suppressNotifications. Should be in transaction. what if tranaction already there?
                if (!suppressNotifications) {
                    eventProxy.fireEvent(Model.Event.PROPERTY_CHANGE, this, oldValue);
                }
            }
        }
        return this;
    };

    ArrayProperty.prototype.getValue = function () {
        var value = [],
            i = 0;
        for (i = 0; i &lt; this.length; i++) {
            value[i] = this[i].getValue();
        }
        return value;
    };
    ArrayProperty.prototype.toJSON = function (includeMetaData) {
        var json = [],
            i = 0,
            value;

        if (this.getMetadata().doNotPersist){
            return undefined;
        } else if (this.getMetadata().doNotPersistValue){
            return [];
        } else {
            for (i = 0; i &lt; this.length; i++) {
                value = this[i].toJSON(includeMetaData);
                if (value !== undefined) {
                    json.push(value);
                }
            }
            return json;
        }
    };

    &#x2F;&#x2F; setValueAt(i, value); suppose to be alternative to a[i] = .. which bypasses events
    ArrayProperty.prototype.setValueAt = function (index, value, metadata) {
        &#x2F;&#x2F; Not sure if function required. So not documented or tested yet.
        var currentProperty = this[index];
        if (currentProperty === undefined){
            this[index] = _createProperty(index, value, this, metadata || {});
            this.trigger(Model.Event.CHILD_CREATED, this[index]);
        } else  {
            if (currentProperty.validateValue(value)) {
                currentProperty.setValue(value);
            } else {
                currentProperty.destroy();
                this[index] = _createProperty(index, value, this, metadata || {});
                this.trigger(Model.Event.CHILD_CREATED, this[index]);
            }
        }
    };

  &#x2F;**
     * Determines if the given value will pass the validation function of this.
     *
     * @example
     * For examples see:  &lt;b&gt;testPropertyValidationFunction&lt;&#x2F;b&gt;
     *
     * @method  validateValue
     *
     * @param  {[Array]} value A value to test against the validation function if it exists.
     * @return {Boolean}      The result of passing value against the validation function if it exists. True otherwise.
     *&#x2F;
    ArrayProperty.prototype.validateValue = function (value) {

        &#x2F;&#x2F; disallow values that are Model Property or PropertyArray objects
        if (value instanceof Property || Model.isArray(value)) {
            &#x2F;&#x2F; this is misleading syntax because other property attributes are not copied like _listener and _parent
            &#x2F;&#x2F; so prevent it and provide alternate. Maybe we could clone, but the suggested is basically a clone and more transparent.
            log(&#x27;error&#x27;, &quot;Incorrect Syntax: use setValue([ArrayProperty].getValue()) instead&quot;);
            return false;
        } else if (!Array.isArray(value)) { &#x2F;&#x2F; newValue is an Array
            log(&#x27;error&#x27;, &quot;Not Supported: Can not set a non-Array Property to an Array. Delete the property and use createProperty passing it the array&quot;);
            return false;
        }

        if (this.hasValidator()) {
            return this._metadata.validator(value);
        }
        return true;
    };

   &#x2F;**
     * The model Object that wraps the JSON.
     *
     * @example
     * For examples see: &lt;b&gt;testPrimitiveSaveLoad&lt;&#x2F;b&gt;,  &lt;b&gt;testObjectsSaveLoad&lt;&#x2F;b&gt;, &lt;b&gt;testComplexSaveLoad&lt;&#x2F;b&gt;
     * &lt;b&gt;testGetNameMethod&lt;&#x2F;b&gt; and &lt;b&gt;testSaveLoadWithMetaData&lt;&#x2F;b&gt;
     *
     * @class Model
     * @constructor
     * @extends Property
     *
     * @param {Object} json?    The json object to be modeled.
     * @param {Object} metadata? May contain the following:
     *                         name - name of the Model, defaults to &quot;root&quot;
     *                         *plus any properties accepted by the createProperty method metadata argument or
     *                          additional data you want stored in the metadata.
     *&#x2F;
    function Model(json, metadata, parent) {
        var jsonModel = json || {},
            modelMetadata = metadata || {},
            modelName = modelMetadata.name !== undefined? modelMetadata.name : &quot;root&quot;,
            modelParent = parent || null;

        if (modelMetadata.name) { &#x2F;&#x2F; name is not part of the metadata.
            delete modelMetadata.name;
        }

        &#x2F;&#x2F;A Model is in itself a Property so lets call our supers constructor
        Property.call(this, modelName, jsonModel, modelParent, modelMetadata);

        if (this.validateValue(jsonModel)) {

            for (var name in jsonModel) {
                if (name.match(Model.PROPERTY_METADATA_SERIALIZED_NAME_REGEX)) { &#x2F;&#x2F; skip special meta data properties
                    continue;
                }

                var value = jsonModel[name];
                var propertyMetadata = jsonModel[name + Model.PROPERTY_METADATA_SERIALIZED_NAME_SUFFIX];

                if (!modelMetadata.thin) {
                    this.createProperty(name, value, propertyMetadata);
                }
            }
        }
    }
    Model.prototype = Object.create(Property.prototype);

    &#x2F;**
     * Determines if the parameter passed in is an modeljs Array Property.
     *
     * @static
     * @method isArray
     *
     * @param  {Property}  property  Property to test whether or not it is an Array Property.
     * @return {Boolean}          true if the Property is an Array Property, false otherwise
     *&#x2F;
    Model.isArray = function (property) {
        return (property instanceof ArrayProperty);
    };

    Model.isProperty = function (property) {
        return Model.isArray(property) || ((property instanceof Property) &amp;&amp; !(property instanceof Model));
    };

    Model.PROPERTY_METADATA_SERIALIZED_NAME_SUFFIX = &quot;__modeljs__metadata&quot;;
    Model.PROPERTY_METADATA_SERIALIZED_NAME_REGEX = &#x2F;__modeljs__metadata$&#x2F;;

    &#x2F;**
     * Gets the value associated with the Model. This will be a json Object.
     *
     * @method  getValue
     *
     * @return {Object} The json Object represented by the model
     *&#x2F;
    Model.prototype.getValue = function () {
        if (this._metadata.thin) {
            return this._myValue;
        }
        return this.toJSON();
    };

    &#x2F;**
     * Called to set the value of a model. If the setValue is the same as the current value,
     * nothing will happen and no change events will be fired. If the value is different it must pass
     * the validator if there is one.  If it does pass the validator and the value is changed, all registered
     * listeners will be notified unless the suppressNotifications option indicates otherwise.
     *
     * @method  setValue
     * @for  Model
     *
     * @param  {[Object]} newValue The Value you want to assign to this.
     * @param  {[Boolean]} suppressNotifications? indicates if listeners should be notified of change.
     *
     * @return {[this]} this for method chaining.
     *&#x2F;
    Model.prototype.setValue = function (value, suppressNotifications) {
        var newValue = value;
        &#x2F;&#x2F; Note: this disallows setting a property to undefined. Only when it&#x27;s first created can it be undefined.
        if (newValue !== undefined &amp;&amp; JSON.stringify(newValue) !== JSON.stringify(this.getValue())) {  &#x2F;&#x2F;TODO  figure this out

            if (this.validateValue(newValue)) {
                var oldValue = this._myValue;

                &#x2F;&#x2F;This model need to be set to the newValue
                var mergeSuccessful = this.merge(newValue, false, suppressNotifications);
                if (mergeSuccessful) {
                    this._myValue = newValue; &#x2F;&#x2F;set Value if successful
                }
                &#x2F;&#x2F; fix suppressNotification should go around Merge!
                if (mergeSuccessful &amp;&amp; !suppressNotifications) {
                    eventProxy.fireEvent(Model.Event.PROPERTY_CHANGE, this, oldValue);
                }
            }
        }
        return this;
    };

       &#x2F;**
     * Determines if the given value will pass the validation function of this.
     *
     * @example
     * For examples see:  &lt;b&gt;testPropertyValidationFunction&lt;&#x2F;b&gt;
     *
     * @method  validateValue
     * @for  Model
     *
     * @param  {[Object]} value A value to test against the validation function if it exists.
     * @return {Boolean}      The result of passing value against the validation function if it exists. True otherwise.
     *&#x2F;
    Model.prototype.validateValue = function (value) {

        &#x2F;&#x2F; disallow values that are Model Property or PropertyArray objects
        if (value instanceof Property || Model.isArray(value)) {
            &#x2F;&#x2F; this is misleading syntax because other property attributes are not copied like _listener and _parent
            &#x2F;&#x2F; so prevent it and provide alternate. Maybe we could clone, but the suggested is basically a clone and more transparent.
            log(&#x27;error&#x27;, &quot;Incorrect Syntax: use setValue([model].getValue()) instead&quot;);
            return false;
        } else if (!isObject(value)) {
            log(&#x27;error&#x27;, &quot;Not Supported: Can&#x27;t set the Model value to a non Model value. Delete the model and use createProperty to change it&#x27;s type&quot;);
            return false;
        }

        if (this.hasValidator()) {
            return this._metadata.validator(value);
        }
        return true;
    };


    var MIN_MODEL_REFRESH_RATE = 100;
    function _createProperty (name, value, parent, metadata) {
        if (value instanceof Property || Model.isArray(value)) {
            log(&#x27;error&#x27;, &quot;Unsupported Operation: Try passing the Model&#x2F;Properties value instead&quot;);
            return;
        } else if (Array.isArray(value)) {
            return new ArrayProperty(name, value, parent, metadata);
        } else if (isObject(value)) {
            var modelMetadata = metadata || {};
            modelMetadata.name = name;
            var model = new Model(value, modelMetadata, parent);
            if (modelMetadata.url &amp;&amp; modelMetadata.refreshRate) {
                if (modelMetadata.refreshRate === -1){
                    makeRemoteRequest(model);
                } else {
                    var interval = Math.max(MIN_MODEL_REFRESH_RATE, modelMetadata.refreshRate);
                    var intervalId = setInterval(makeRemoteRequest.bind(null, model), interval);
                    model.getMetadata().intervalId = intervalId;
                }
            }
            return model;
        } else {
            return new Property(name, value, parent, metadata);
        }
    }

    &#x2F;**
     * Creates the property with the given name on this. This will fire the childCreated event on the parent. The
     * metadata can contain custom keys or any of the special keys below.
     *
     * @example
     *     var model = new Model();
     *     model.createProperty(&quot;number&quot;, 1) &#x2F;&#x2F; a simple property (model.number)
     *     .createProperty(&quot;subModel&quot;, { &#x2F;&#x2F; a property that is a subModel (model.subModel and model.subModel.str)
     *         str: &quot;stringProperty&quot;
     *     })
     *     .createProperty(&quot;positiveNumber&quot;, 2, { &#x2F;&#x2F; a property with a positiveNumber validator and a custom attribute
     *         validator: function (value) {
     *             return value &gt; 0;
     *         },
     *         customMetadata: &quot;this Property is special&quot;
     *     }),
     *     .createProperty (&quot;remoteModel&quot;, {prop1: &quot;defaultValue&quot;}, { &#x2F;&#x2F; a remote model populated via the twitter rest api.
     *         url: &quot;http:&#x2F;&#x2F;search.twitter.com&#x2F;search.json?q=tennis&amp;callback=$jsonpCallback&quot;,
     *         doNotPersist: true,
     *         refreshRate: -1, &#x2F;&#x2F; -1 means fetch once.
     *         isJSONPurl: true
     *     }); &#x2F;&#x2F; Note the method chaining.
     *
     * For examples see: &lt;b&gt;testModelCreationUsingCreatePropertyMethod, testThinModel&lt;&#x2F;b&gt;
     *
     * @method  createProperty
     *
     * @param {String} name    Name of the property
     * @param {[String, Boolean, Number, null, Date, Function, Object]} value   Property value
     * @param {[Object]} metadata? A hash of metadata associated with the property. You can put any metadata you want. However the following keys have special meaning and are reserved for use by the framework.
     *                         &lt;ul&gt;&lt;li&gt;
     *                             &lt;b&gt;validator&lt;&#x2F;b&gt; {Function} - a function to validate if the new value is valid before it is assigned.
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;Formatter&lt;&#x2F;b&gt; {Function} - a function that takes this.getValue() as input and output the value you want returned by the getFormattedValue function. See the documentation of getFormattedValue for more details.
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;url&lt;&#x2F;b&gt; {String} - the resource this model should use to get it&#x27;s value. Resource must return json. *Must be used with refreshRate*
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;refreshRate&lt;&#x2F;b&gt; {Number} - the interval used to query the url for changes. must be &gt; 100 or -1. -1 indicates to only fetch value once. *Must be used with url*
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;isJSONPurl&lt;&#x2F;b&gt; {Boolean} - if true will use JSONP to fetch the data. The url provided must have the string &quot;$jsonpCallback&quot; where the jsonp callback function should be inserted.
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;doNotPersist&lt;&#x2F;b&gt; {Boolean} - property will not exist in the json object returned by the toJSON method.
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;doNotPersistValue&lt;&#x2F;b&gt; {Boolean} - will clear the value of the property when toJSON is called. For Object and Array types the value will be and empty object&#x2F;array. Else it will be undefined. *Note metadata can still be persisted.
     *                         &lt;&#x2F;li&gt;&lt;li&gt;
     *                             &lt;b&gt;thin&lt;&#x2F;b&gt; {Boolean} - will create a model property representing this but not model any of it&#x27;s children properties
     *                         &lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;
     *
     * @param  {[Boolean]} suppressNotifications? indicates if listeners should be notified of change.
     *
     * @return {Model}         Returns this for method chaining
     *&#x2F;
    Model.prototype.createProperty = function createProperty(name, value, metadata, suppressNotifications) {

        if (value instanceof Property || Model.isArray(value)) {
            log(&#x27;error&#x27;, &quot;Unsupported Operation: Try passing the Model&#x2F;Properties value instead&quot;);
            return this;
        } else if (this._metadata.thin) {
            log(&#x27;error&#x27;, &quot;Unsupported Operation: Can not create a property on a Thin model.&quot;);
            return this;
        }

        this[name] = _createProperty(name, value, this, metadata);
        if (!suppressNotifications) {
            this.trigger(Model.Event.CHILD_CREATED, this[name]);
        }
        return this;
    };

    &#x2F;**
     * Clones the Model rooted at this keeping all metadata that exist, but not keeping any event listeners.
     * The name of all properties are adjusted to reflect it&#x27;s new root.
     *
     * @example
     *     var newModel = model.clone(); &#x2F;&#x2F; clone root model
     *     var clonedSubModel = model.subModel.clone(); &#x2F;&#x2F; clone subModel
     * For more examples: &lt;b&gt;testModelClone&lt;&#x2F;b&gt;
     *
     * @method  clone
     *
     * @return {Model}  Returns a new Model object rooted at this, keeping any metadata but no event listeners.
     *&#x2F;
    Model.prototype.clone = function () {
        var metadata = JSON.parse(JSON.stringify(this.getMetadata()));
        metadata.name = this.getShortName();
        return new Model(this.toJSON(true), metadata);
    };

    function mergeLoop(model, json, doModification, keepOldProperties, suppressNotifications) {

        for (var name in json) {
            if (!name.match(Model.PROPERTY_METADATA_SERIALIZED_NAME_REGEX)) {
                var value = json[name];
                if (model[name]) {
                    if (isObject(value)) { &#x2F;&#x2F; right hand side is an object
                        if (model[name] instanceof Model) { &#x2F;&#x2F; left is and Model. -&gt; merging objects
                            if (!mergeLoop(model[name], value, doModification, keepOldProperties, suppressNotifications)) {
                                return false;
                            }
                        } else {
                            &#x2F;&#x2F; Trying to assign a model to a property. This will fail.
                            return false;
                        }

                    } else { &#x2F;&#x2F; right hand side is not an object.
                        if (Model.isProperty(model[name])) { &#x2F;&#x2F; left is a Property -&gt; merging properties
                            if (doModification) {
                                model[name].setValue(value, suppressNotifications);
                            }
                        } else {
                            &#x2F;&#x2F; Trying to assign a property to a Model. This will fail.
                            return false;
                        }
                    }
                } else { &#x2F;&#x2F;create new property
                    if (doModification) {
                        model.createProperty(name, value, {}, suppressNotifications);
                    }
                }
            }

            &#x2F;&#x2F; delete properties that are not found in json
            if (!keepOldProperties &amp;&amp; doModification) {
                for (var modelProp in model) {
                    if (!json[modelProp] &amp;&amp; &#x2F;&#x2F;property does exist in merge
                            model.hasOwnProperty(modelProp) &amp;&amp;
                            (model[modelProp] instanceof Property || Model.isArray(model[modelProp])) &amp;&amp;
                            modelProp !== &#x27;_parent&#x27;) { &#x2F;&#x2F; for ECMA backwards compatibility &#x27;_parent&#x27; must be filter since its non-enumerable
                        model[modelProp].destroy(suppressNotifications);
                    }
                }
            }
        }
        return true;
    }

    &#x2F;**
     * Preforms the merge operation on this. The merge operation will add properties that exist in the merged object
     * but not in this, remove those that are not found in the merged object (unless keepOldProperties is set to true)
     * and will call setValue for those that exist in both. Note the operation will log an error to the console, return
     * false, and not modify the object if any of the setValue operation are not valid. Not valid set operations included
     * those that try to set a value from a property to a model and vise versa.
     *
     * @example
     * For an example see: &lt;b&gt;testModelMergeMethod&lt;&#x2F;b&gt;
     *
     * @method  merge
     *
     * @param  {[Object]} json              The json object to have merged.
     * @param  {[Boolean]} keepOldProperties? True if you want to keep properties that exist in this but not in the passed in json, Otherwise they will be deleted. Defaults to false.
     * @param  {[Boolean]} suppressNotifications? indicates if listeners should be notified of change.
     * @return {Boolean}                   Returns true if merge was successful, false otherwise.
     *&#x2F;
    Model.prototype.merge = function (json, keepOldProperties, suppressNotifications) {
        &#x2F;&#x2F;will merge the properties in json with this. result will be the same as the Object extend.
        &#x2F;&#x2F;if a property exists in the model but not in the json it will only be kept if keepOldProperties is true.
        if (this._metadata.thin) {
            this._myValue = json;
            return true;
        } else if (mergeLoop(this, json, false, keepOldProperties)) { &#x2F;&#x2F; check if merge will be successful
            Model.startTransaction();
            mergeLoop(this, json, true, keepOldProperties, suppressNotifications);
            Model.endTransaction();
            return true;
        } else {
            log(&#x27;error&#x27;, &quot;Merge operation Not Supported: An assignment was not valid. Model not modified&quot;);
            return false;
        }
    };


    &#x2F;**
     * Retrieves the json representation of this. This json representation can be used in the Model Constructor
     * to recreate the same Model object. If you use includeMetaData validator metadata will be included.
     * Properties that have the doNotPersist flag in it&#x27;s metadata will have it&#x27;s value nullified. This means
     * properties will have the value set to &#x27;undefined&#x27; while models will be set to an empty object ({}).
     *
     * @example
     * For an example see: &lt;b&gt;testSaveLoadWithMetaData&lt;&#x2F;b&gt; and &lt;b&gt;testDoNotPersist&lt;&#x2F;b&gt;
     *
     * @method  toJSON
     *
     * @param  {[Boolean]} includeMetaData? indicates if model meta data should be included in the returned JSON. Defaults to false.
     * @return {[Object]}                 The json representation of the Model.
     *&#x2F;
    Model.prototype.toJSON = function (includeMetaData) {
        var json = {};
        if (this._myValue === undefined || this.getMetadata().doNotPersist) {
            return undefined;
        } else if (this.getMetadata().doNotPersistValue){
            return {};
        } else if (this.getMetadata().thin) {
            return this.getValue();
        } else {
            for (var name in this) {
                if (this.hasOwnProperty(name) &amp;&amp; name !== &#x27;_parent&#x27;) {
                    &#x2F;&#x2F; for ECMA backwards compatibility &#x27;_parent&#x27; must be filter since its non-enumerable. and would cause infinite recursion
                    var property = this[name];
                    if (!property.getMetadata().doNotPersist) {
                        json[name] = property.toJSON(includeMetaData);
                        if (includeMetaData &amp;&amp; !isEmptyObject(property.getMetadata())) {
                            json[name + Model.PROPERTY_METADATA_SERIALIZED_NAME_SUFFIX] = property.getMetadata();
                        }
                    }
                }
            }
            return json;
        }
    };

    &#x2F;**
     * A global formatter used to calculate the formatted value of a Property. If defined the function
     * will be called when getFormattedValue gets called. The function should accept the value to be formatted
     * as the first argument and expect &#x27;this&#x27; to be the Property. The formatter must be able to handle any
     * input type as a value.
     *
     * @example
     *     Model.Formatter = function (value) { &#x2F;&#x2F;makes all strings uppercase
     *         if (typeof value === &#x27;string&#x27;) {
     *             return value.toUpperCase();
     *         }
     *         return value;
     *     }
     *
     * @for  Model
     * @property  Formatter
     * @static
     *
     * @type {Function} A format function whose first argument is the value to be formatted
     * @return {any}    The formatted result
     *&#x2F;
    Model.Formatter = undefined;

    &#x2F;**
     * If logging is enabled any warning or incorrect uses of the api will result in output to the console
     * if it exists.
     *
     * @property isLoggingEnabled
     * @default false
     * @static
     * @type {Boolean} Indicates if Logging is enabled
     *&#x2F;
    Model.enableLogging = false;

    &#x2F;**
     * Searchs the given model for the property of the given name and returns it.
     *
     * @method find
     * @static
     *
     * @param  {[Property, Model, ArrayProperty]} model        The model to search.
     * @param  {[String]} propertyName The fully quialified name of the property. Equal to the getName() value.
     * @return {[Property, Model, ArrayProperty]}   The model object of the given name, null otherwise.
     *&#x2F;
    Model.find = function (model, propertyName) {
        var modelName = model.getName();
        var modelParts = modelName.split(&#x27;&#x2F;&#x27;);
        var propertyParts = propertyName.split(&#x27;&#x2F;&#x27;);
        var diff = &quot;&quot;;

        if (modelParts[0] !== propertyParts[0]) {
            return null;  &#x2F;&#x2F;not part of same model
        }

        var i = 0;
        while (modelParts[i] === propertyParts[i] &amp;&amp; i &lt; propertyParts.length) {
            i++;
        }

        var j = i;
        var commonDenominator = model;
        for ( j = i; j &lt; modelParts.length; j++) {
            commonDenominator = commonDenominator._parent;
        }

        var prop = commonDenominator;
        for (var k = i; k &lt; propertyParts.length; k++) {
            prop = prop[propertyParts[k]];
        }
        if (prop.getName() === propertyName){
            return prop;
        }
        return null;
    };


   &#x2F;**
     * Begins a transaction. All events will be put into the queued. To be fired when endTransaction is called.
     *
     * @example
     * For an examples see &lt;b&gt;testModelTransactions&lt;&#x2F;b&gt;
     *
     * @for  Model
     * @method  startTransaction
     * @static
     *
     *&#x2F;
    Model.startTransaction = function () {
        eventProxy.startTransaction();
    };


    &#x2F;**
     * Ends the current transaction causing all queued up events to be fired according to the global eventOptization settings or the settings passed in if they exist.
     *
     * @example
     *     model.endTransaction(); &#x2F;&#x2F;uses settings found in Model.TRANSACTION_OPTIONS
     *     model.endTransaction({   &#x2F;&#x2F; override the Model.TRANSACTION_OPTIONS settings for this transaction
     *         fireOnlyMostRecentPropertyEvent: false,
     *         flattenCallbacks: true,
     *         flattenCallbacksByHash: true
     *     })
     * For more examples see: &lt;b&gt;testFlattenCallbacks&lt;&#x2F;b&gt;, &lt;b&gt;testFlattenCallbacksByHash&lt;&#x2F;b&gt;,
     *      &lt;b&gt;testModelEndTransactionWithOptions&lt;&#x2F;b&gt;
     *
     * @for     Model
     * @method  endTransaction
     * @static
     *
     * @param  {Object} options? A map of Model.TRANSACTION_OPTIONS options that you want overridden when clearing this transaction queue.
     *&#x2F;
    Model.endTransaction = function (options) {
        var originalTransactionOptions;

        if (options) { &#x2F;&#x2F; if option override global setting keeping them so they can be restored later
            originalTransactionOptions = JSON.parse(JSON.stringify(Model.TRANSACTION_OPTIONS));
            Model.TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent = !!options.fireOnlyMostRecentPropertyEvent;
            Model.TRANSACTION_OPTIONS.flattenCallbacks = !!options.flattenCallbacks;
            Model.TRANSACTION_OPTIONS.flattenCallbacksByHash = !!options.flattenCallbacksByHash;
            Model.TRANSACTION_OPTIONS.suppressAllEvents = !!options.suppressAllEvents;
        }

        eventProxy.endTransaction();

        if (options) { &#x2F;&#x2F;restore global settings
            Model.TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent = originalTransactionOptions.fireOnlyMostRecentPropertyEvent;
            Model.TRANSACTION_OPTIONS.flattenCallbacks = originalTransactionOptions.flattenCallbacks;
            Model.TRANSACTION_OPTIONS.flattenCallbacksByHash = originalTransactionOptions.flattenCallbacksByHash;
            Model.TRANSACTION_OPTIONS.suppressAllEvents = !!options.suppressAllEvents;
        }

    };

    &#x2F;**
     * Determines if you are currently in a start&#x2F;end transaction block.
     *
     * @example
     * For an examples see &lt;b&gt;testModelTransactions&lt;&#x2F;b&gt;
     *
     * @for  Model
     * @method  inTransaction
     * @static
     *
     * @return {[Boolean]} True if your in a transaction block, false otherwise.
     *&#x2F;
    Model.inTransaction = function() {
        return eventProxy.inTransaction();
    };

    &#x2F;&#x2F; does property change bubble a model change?
    &#x2F;&#x2F; does model change include this or just it&#x27;s children?
    &#x2F;&#x2F; what about change?
    Model.Event = {
        &#x2F;**
         * The PROPERTY_CHANGE event is triggered only when the value of the property has changed
         * via setValue. When triggered it will bubble up a MODEL_CHANGED event. Listen to this event
         * if you only want to be notified of direct changes to the property and not changes to any of
         * it&#x27;s children. This is what the onChange(callback, false) does.
         * PROPERTY_CHANGE event callbacks will be called with the following arguments:
         *      &lt;ul&gt;
         *      &lt;li&gt;this = the property listening to the event&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[0] = the property in it&#x27;s current state&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[1] = the old value.&lt;&#x2F;li&gt;
         *      &lt;&#x2F;ul&gt;
         * @property Event.PROPERTY_CHANGE
         * @static
         * @type {String}
         *&#x2F;
        PROPERTY_CHANGE: &quot;propertyChange&quot;,
        &#x2F;**
         * The MODEL_CHANGE event is triggered when the value of any of the property&#x27;s
         * children have changed. This includes child properties being created or destroyed.
         * When triggered on a property it will bubble the event up it&#x27;s model tree.
         * The callback will have the following arguments:
         *      &lt;ul&gt;
         *      &lt;li&gt;this = the property listening to the event. (or is registared with the callback)&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[0] = the property that triggered the modelChange&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[1] = the old value.&lt;&#x2F;li&gt;
         *      &lt;&#x2F;ul&gt;
         * @property Event.MODEL_CHANGE
         * @static
         *&#x2F;
        MODEL_CHANGE: &quot;modelChange&quot;,
        &#x2F;**
         * The CHANGE event is psudo event equalvlant to a PROPERTY_CHANGE and MODEL_CHANGE event.
         * It is the event used when registaring a listener using the onChange(callback, true) method.
         * The callback will have the following arguments:
         *      &lt;ul&gt;
         *      &lt;li&gt;this = the property listening to the event&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[0] = the property in it&#x27;s current state&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[1] = the old value.&lt;&#x2F;li&gt;
         *      &lt;&#x2F;ul&gt;
         * @property Event.CHANGE
         * @static
         * @type {String}
         *&#x2F;
        CHANGE: &quot;change&quot;,
        &#x2F;**
         * The DESTROY event is triggered when destroy() method called on a property. It than triggers
         * a CHILD_DESTROYED event on it&#x27;s parent.
         * The callback will have the following arguments:
         *      &lt;ul&gt;
         *      &lt;li&gt;this = the destroyed property&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[0] = the destroyed property&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[1] = the old value.&lt;&#x2F;li&gt;
         *      &lt;&#x2F;ul&gt;
         * @property Event.DESTROY
         * @static
         * @type {String}
         *&#x2F;
        DESTROY: &quot;destroy&quot;,
        &#x2F;**
         * The CHILD_CREATED event is triggered when a new property is created. It&#x27;s triggered on the
         * parent and propergates a MODEL_CHANGE event up the model tree.
         * The callback will have the following arguments:
         *      &lt;ul&gt;
         *      &lt;li&gt;this = the parent property&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[0] = the created property&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[1] = undefined&lt;&#x2F;li&gt;
         *      &lt;&#x2F;ul&gt;
         * @property Event.CHILD_CREATED
         * @static
         * @type {String}
         *&#x2F;
        CHILD_CREATED: &quot;childCreated&quot;,
        &#x2F;**
         * The CHILD_Destroyed event is triggered when a child property is destroyed. It triggered on the
         * parent and propergates a MODEL_CHANGE event up the model tree.
         * The callback will have the following arguments:
         *      &lt;ul&gt;
         *      &lt;li&gt;this = the parent property&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[0] = the destroyed property&lt;&#x2F;li&gt;
         *      &lt;li&gt;arg[1] = undefined&lt;&#x2F;li&gt;
         *      &lt;&#x2F;ul&gt;
         * @property Event.CHILD_DESTROYED
         * @static
         * @type {String}
         *&#x2F;
        CHILD_DESTROYED: &quot;childDestroyed&quot;
    };


    Model.TRANSACTION_OPTIONS = {
        &#x2F;**
            Only fires the last event of a property during a transaction.
            @Example For an example see &lt;b&gt;testFireOnlyMostRecentPropertyEvent&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.fireOnlyMostRecentPropertyEvent
            @default false
            @static
            @type {boolean}
        *&#x2F;
        fireOnlyMostRecentPropertyEvent: false,
        &#x2F;**
            Will make sure a callback only gets called only once during a transaction. Even if registered with several properties.
            @Example For an example see &lt;b&gt;testFlattenCallbacks&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.flattenCallbacks
            @default false
            @static
            @type {boolean}
         **&#x2F;
        flattenCallbacks: false,
        &#x2F;**
            Will make sure callbacks identified by .hash only gets called only once during a transaction. Even if registered with several properties.
            @Example For an example see &lt;b&gt;testFlattenCallbacksByHash&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.flattenCallbacksByHash
            @default false
            @static
            @type {boolean}
        *&#x2F;
        flattenCallbacksByHash: false,
        &#x2F;**
            Will guarentee that no event are fired during a transaction
            @Example For an example see &lt;b&gt;testSuppressAllEvents&lt;&#x2F;b&gt;
            @property TRANSACTION_OPTIONS.suppressAllEvents
            @default false
            @static
            @type {boolean
        *&#x2F;
        suppressAllEvents: false

    };
    Object.seal(Model.TRANSACTION_OPTIONS);

    var oldModel = globalNS.Model;
    &#x2F;**
     * Release control of the global window.Model variable restoring it to its previous value
     *
     * @Example
     *     &#x2F;&#x2F; window.Model is restore to previous value and localModel now holds the window.Model reference
     *     var localModel = window.Model.noConflict();
     * For an example see &lt;b&gt;testModelNoConflict&lt;&#x2F;b&gt;
     *
     * @for  Model
     * @method  noConflict
     * @static
     *
     * @return {[Model]} The window Model variable that was just released.
     *&#x2F;
    Model.noConflict = function () {
        globalNS.Model = oldModel;
        return this;
    };


   if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
        define([], function () { 
            return Model;
        });
    } else if (typeof exports !== &#x27;undefined&#x27;) {
        if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
            exports = module.exports = Model;
        }
        exports.Model = Model;
    } else {
        &#x2F;** @global *&#x2F;
        window[&quot;Model&quot;] = Model;
    }

}(typeof window !== &#x27;undefined&#x27; ? window : GLOBAL)); &#x2F;&#x2F;window in the browser and GLOBAL in node
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
